<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vue createElement与elementUI中表头修改</title>
      <link href="/2020-04-02-22.html"/>
      <url>/2020-04-02-22.html</url>
      
        <content type="html"><![CDATA[<h2 id="vue-createElement"><a href="#vue-createElement" class="headerlink" title="vue $createElement"></a>vue $createElement</h2><p>Vue推荐在大多数情况下用模板来创建你的 HTML（template中写dom）。然而在一些场景中，你真的需要 JavaScript 的完全编程的能力。这时你可以用渲染函数，它比模板更接近编译器。</p><p><em>createElement在正常开发下是一个不太常用的函数，他可以创建虚拟dom（VNode）</em></p><h3 id="createElement参数"><a href="#createElement参数" class="headerlink" title="createElement参数"></a>createElement参数</h3><pre><code class="js">createElement(    // {String | Object | Function}    // 一个 HTML 标签名、组件选项对象，或者    // resolve 了上述任何一种的一个 async 函数。必填项。    &#39;div&#39;,    // {Object}    // 一个与模板中属性对应的数据对象。可选。    {        // (详情见下一节)    },    // {String | Array}    // 子级虚拟节点 (VNodes)，由 `createElement()` 构建而成，    // 也可以使用字符串来生成“文本虚拟节点”。可选。    [        &#39;先写一些文字&#39;,        createElement(&#39;h1&#39;, &#39;一则头条&#39;),        createElement(MyComponent, {        props: {            someProp: &#39;foobar&#39;        }        })    ])</code></pre><p>在官方文档中，createElement可以接收三个参数</p><ul><li><code>{String | Object | Function}</code> 标签名称</li><li><code>Object</code> 节点上的属性，样式，事件等内容（下面会详细列出具体写法）</li><li><code>{String | Array | createElement()}</code> 存储节点中的子节点或内容，如果有多个用数组表示</li></ul><h4 id="第二个参数的内容"><a href="#第二个参数的内容" class="headerlink" title="第二个参数的内容"></a>第二个参数的内容</h4><pre><code class="js">{    // 与 `v-bind:class` 的 API 相同，    // 接受一个字符串、对象或字符串和对象组成的数组    class: {        foo: true,        bar: false    },    // 与 `v-bind:style` 的 API 相同，    // 接受一个字符串、对象，或对象组成的数组    style: {        color: &#39;red&#39;,        fontSize: &#39;14px&#39;    },    // 普通的 HTML attribute（属性）    attrs: {        id: &#39;foo&#39;    },    // 组件 prop (接收数据（&lt;my-component :myProp=&quot;data&quot; /&gt;）)    props: {        myProp: &#39;bar&#39;    },    // DOM 属性    domProps: {        innerHTML: &#39;baz&#39;    },    // 事件监听器在 `on` 属性内，    // 但不再支持如 `v-on:keyup.enter` 这样的修饰器。    // 需要在处理函数中手动检查 keyCode。    on: {        click: this.clickHandler    },    // 仅用于组件，用于监听原生事件，而不是组件内部使用    // `vm.$emit` 触发的事件。    nativeOn: {        click: this.nativeClickHandler    },    // 自定义指令。注意，你无法对 `binding` 中的 `oldValue`    // 赋值，因为 Vue 已经自动为你进行了同步。    directives: [        {            name: &#39;my-custom-directive&#39;,            value: &#39;2&#39;,            expression: &#39;1 + 1&#39;,            arg: &#39;foo&#39;,            modifiers: {                bar: true            }        }    ],    // 作用域插槽的格式为    // { name: props =&gt; VNode | Array&lt;VNode&gt; }    scopedSlots: {        default: props =&gt; createElement(&#39;span&#39;, props.text)    },    // 如果组件是其它组件的子组件，需为插槽指定名称    slot: &#39;name-of-slot&#39;,    // 其它特殊顶层属性    key: &#39;myKey&#39;,    ref: &#39;myRef&#39;,    // 如果你在渲染函数中给多个元素都应用了相同的 ref 名，    // 那么 `$refs.myRef` 会变成一个数组。    refInFor: true}</code></pre><p>复制于<a href="https://cn.vuejs.org/v2/guide/render-function.html" target="_blank" rel="noopener">官方文档</a></p><h3 id="使用createElement创建的组件的简单示例"><a href="#使用createElement创建的组件的简单示例" class="headerlink" title="使用createElement创建的组件的简单示例"></a>使用<code>createElement</code>创建的组件的简单示例</h3><pre><code class="js">import Vue from &#39;vue&#39;;Vue.component(&#39;comp&#39;,{    render(h) {        return h(&#39;div&#39;,{        style: {            background: &#39;red&#39;,        },        on: {            click: this.compClick        }        },&#39;aaaaaaaaaaaaaaa&#39;)    },    methods: {        compClick(e) {            console.log(111111111111)        }    }})</code></pre><h3 id="待完善"><a href="#待完善" class="headerlink" title="待完善"></a>待完善</h3><ol><li>在vue的createElement源码中，后两个参数的具体用途</li></ol><pre><code class="js">export function createElement (    context: Component,    tag: any,    data: any,    children: any,    normalizationType: any,    alwaysNormalize: boolean): VNode | Array&lt;VNode&gt; {    if (Array.isArray(data) || isPrimitive(data)) {        normalizationType = children        children = data        data = undefined    }    if (isTrue(alwaysNormalize)) {        normalizationType = ALWAYS_NORMALIZE    }    return _createElement(context, tag, data, children, normalizationType)}</code></pre><h2 id="elementUI中表头修改"><a href="#elementUI中表头修改" class="headerlink" title="elementUI中表头修改"></a>elementUI中表头修改</h2><p>在用elementUI + vue制作表格时，可能会遇需求是 把表头修改成不止简单的<code>string</code>类型</p><p>比如下面这个例子，需求在表头中添加一个点击弹出的弹框提示</p><p><img src="/blog-img/22-1.jpg" alt="需求a"><br>and<br><img src="/blog-img/22-2.jpg" alt="需求b"></p><p>这时就需要使用<code>table</code>中<code>render-header</code>方法配合组件<code>&lt;el-popover&gt;</code>来实现</p><h3 id="render-header方法"><a href="#render-header方法" class="headerlink" title="render-header方法"></a><code>render-header</code>方法</h3><p>| <code>render-header</code> | 列标题 <code>Label</code> 区域渲染使用的 | <code>Function(h, { column, $index })</code> |</p><p>在<code>render-header</code>方法返回的参数中，<code>h</code>的用法和<code>createElement</code>一样</p><pre><code class="html">&lt;template&gt;......    &lt;el-table-column :render-header=&quot;columnRenderer&quot;&gt;......&lt;template/&gt;&lt;script&gt;......columnRenderer(h, { column, $index }) {      return [        &#39;表头&#39;,         h(          &#39;el-popover&#39;,          {            props: {              content: &#39;这是弹出的内容&#39;,              placement: &#39;top&#39;,              effect: &quot;light&quot;,            },          },          [            h(&#39;span&#39;, {              class: {                &#39;el-icon-question&#39;: true // el中 问号 iconfont的class              },              slot: &#39;reference&#39;            })          ]        )      ]    },......&lt;/script&gt;</code></pre><p>或者使用组件<code>&lt;Tooltip&gt;</code>配合</p><pre><code class="html">&lt;template&gt;......    &lt;el-table-column :render-header=&quot;columnRenderer&quot;&gt;......&lt;template/&gt;&lt;script&gt;......columnRenderer(h, { column, $index }) {      return [        &#39;表头&#39;,         h(          &#39;el-tooltip&#39;,          {            props: {              content: &#39;这是弹出的内容&#39;,              placement: &#39;top&#39;,            },          },          [            h(&#39;span&#39;, {              class: {                &#39;el-icon-question&#39;: true // el中 问号 iconfont的class              },            })          ]        )      ]    },......&lt;/script&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> element-ui </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转载】 JavaScript 装饰器</title>
      <link href="/2020-03-24-21.html"/>
      <url>/2020-03-24-21.html</url>
      
        <content type="html"><![CDATA[<p>转载于 <a href="https://juejin.im/post/5e7822c3e51d4526f23a45ae" target="_blank" rel="noopener">掘金 作者：sh22n</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS运行机制、宏任务与微任务</title>
      <link href="/2020-03-23-20.html"/>
      <url>/2020-03-23-20.html</url>
      
        <content type="html"><![CDATA[<h2 id="JS是单线程的"><a href="#JS是单线程的" class="headerlink" title="JS是单线程的"></a>JS是单线程的</h2><blockquote><p>avaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。<br>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？<br>所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。<br>为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。<br>——阮老师</p></blockquote><h2 id="JS运行机制"><a href="#JS运行机制" class="headerlink" title="JS运行机制"></a>JS运行机制</h2><p>要了解事件循环和任务队列，弄明白JS的运行机制就明白了</p><ol><li>所有的同步任务都在“主线程”上执行，形成一个“执行栈”。</li><li>在主线程之外，还有一个叫“任务队列”的东西，只要有异步任务执行完毕，就会把运行结果放在“任务队列”中“排队”。</li><li>当“执行栈”中的所有任务都执行完了，系统就会看看“任务队列”中有没有正在排队的事件，如果有就开始按照排队的顺序处理这些事件。</li></ol><p><strong>主线程：</strong> JS是单线程的，这个线程就被成为主线程，执行代码用的。主线程会先执行执行栈中的东西，当执行栈为空时，才会看任务队列中是否存在需要被执行的代码，如果有，就把任务队列中的东西按顺序拿到执行栈中执行<br><strong>执行栈：</strong> 执行栈是一个用来存放等待执行的同步任务的地方，当我们调用一个方法（&lt;script&gt;&lt;function&gt;等）时，JS会生成一个与这个方法相对应的执行环境，也叫执行上下文（执行环境不是执行栈），执行环境中存在着这个方法的私有参数、作用域等东西，因为JS是单线程的，所以当很多方法被依次调用时，JS会先 解析 这些方法，把同步任务放在“执行栈”中排队<br><strong>任务队列：</strong> 任务队列也叫消息队列，回调队列，异步操作会被放在任务队列中等待执行</p><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>在“JS运行机制”中，主线程每次清空一次“执行栈”后，就算是执行了一次事件循环。<br>主线程每次清空栈后，就去任务队列中检查是否有任务，如果有，就每次取出一个放在执行战中执行，一直循环，这个过程被称为“事件循环”  </p><p><img src="/blog-img/20-1.png" alt="事件循环"><br>经典老图.jpg</p><p>事件循环和宏任务、微任务的关系</p><p><img src="/blog-img/20-2.png" alt="事件循环和宏任务、微任务的关系"><br>经典老图2.jpg</p><h2 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h2><p><strong>宏任务：</strong> 每一次执行栈执行的代码就是一个宏任务</p><p>常见宏任务</p><ul><li>script(整体代码)</li><li>setTimeout</li><li>setInterval</li></ul><p><strong>微任务：</strong> 在每一次宏任务执行结束后执行的任务（在下一个宏任务之前，也在渲染之前）</p><p>常见微任务</p><ul><li>Promise.then</li><li>async await</li></ul><h2 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h2><table><thead><tr><th></th><th>执行栈</th><th>宏任务（执行栈）</th><th>微任务（如果有的话）</th><th>宏任务</th><th>微任务</th><th>宏任务</th><th>微任务</th><th>…</th></tr></thead><tbody><tr><td>备注</td><td>最初js代码</td><td>任务队列中的宏任务放在执行栈中执行</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><pre><code class="js">async function ac() {    console.log(&#39;ac-start&#39;)    await ac2();    console.log(&#39;ac-end&#39;)}async function ac2 () {    console.log(&#39;ac2&#39;)}setTimeout(() =&gt; {    console.log(&#39;setTimeout&#39;)    new Promise(resolve =&gt; {        console.log(&#39;promise-body&#39;)        resolve()    }).then(() =&gt; {        console.log(&#39;promise-then&#39;)    })}, 0)setTimeout(() =&gt; { // setTimeout2    console.log(&#39;setTimeout2&#39;)})ac()console.log(&#39;window&#39;)</code></pre><ul><li>首先是第一遍事件循环  </li><li>从第一行开始往下走，首先创建函数ac和函数ac2，没有调用，所以没有执行，  </li><li>往下走 看到了setTimeout，setTimeout的第二个形参为”0”，也就是说延时0秒执行，所以将它在0秒后排到任务队列中（0秒或者为空都不会立即执行，而是放在任务队列中）  </li><li>再往下走，又是一个setTimeout，我们暂时叫他setTimeout2，同样当做宏任务放在任务队列中  </li><li>接下来是ac()，调用ac函数，  </li><li>在ac函数中，首先输出log‘ac-start’，接下来是ac2()，开始执行ac2  </li><li>ac2输出log‘ac2’，没有返回值，返回undefined，回到ac函数中  </li><li>由于ac函数时async函数，在await后的内容放在微任务队列中  </li><li>ac()调用完毕后继续往下走，输出log‘window’  </li><li>主进程走完后，看一下是否有微任务，有的话按顺序执行微任务，于是开始继续执行ac函数，输出log‘ac-end’，然后ac函数返回undefined  </li><li><strong>第一遍事件循环结束</strong>，现在输出ac-start — ac2 — window — ac-end  </li><li>第二遍事件循环，从任务队列中取第一个，也就是setTimeout中的函数，开始执行  </li><li>首先输出log‘setTimeout’  </li><li>往下走看见promise函数，执行函数中的内容  </li><li>第一行输出log‘promise-body’  </li><li>第二行promise函数返回resolve，把then中的内容放在微任务队列中  </li><li>setTimeout执行结束，开始查看有没有微任务，执行微任务  </li><li>执行then中的函数，输出log‘promise-then’  </li><li><strong>第二遍事件循环结束</strong>，现在输出ac-start — ac2 — window — ac-end — setTimeout — promise-body — promise-then  </li><li>第三遍事件循环，从任务队列中取出第一个（也是最后一个），setTimeout2中的函数，开始执行  </li><li>输出log‘setTimeout2’  </li><li>在之后没有宏任务额微任务了，执行结束  </li><li><strong>最终输出</strong> ac-start — ac2 — window — ac-end — setTimeout — promise-body — promise-then — setTimeout2  </li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将网页打包成应用程序</title>
      <link href="/2020-03-20-19.html"/>
      <url>/2020-03-20-19.html</url>
      
        <content type="html"><![CDATA[<h2 id="需求：-将一个已经上线的后台管理系统（只兼容Chrome）打包成一个不需要谷歌浏览器就可以运行的软件"><a href="#需求：-将一个已经上线的后台管理系统（只兼容Chrome）打包成一个不需要谷歌浏览器就可以运行的软件" class="headerlink" title="需求： 将一个已经上线的后台管理系统（只兼容Chrome）打包成一个不需要谷歌浏览器就可以运行的软件"></a><em>需求：</em> 将一个已经上线的后台管理系统（只兼容Chrome）打包成一个不需要谷歌浏览器就可以运行的软件</h2><h2 id="需要安装："><a href="#需要安装：" class="headerlink" title="需要安装："></a><em>需要安装：</em></h2><ol><li><code>npm install electron -g</code></li><li><code>npm install electron-packager -g</code></li><li>WinRAR解压工具（或者2345等其他解压工具也可以）</li><li>Powershell 3 或 3 以上版本（electron-packager打包需要）</li><li>NET 4.5 或 4.5 以上版本（electron-packager打包需要）</li></ol><p><em>此例只进行最简单的转换，详细electron用法请参考<a href="https://www.w3cschool.cn/electronmanual/" target="_blank" rel="noopener">electron中文文档</a></em></p><h2 id="运行文件"><a href="#运行文件" class="headerlink" title="运行文件"></a>运行文件</h2><p>新建文件夹，演示中暂命名为<code>app</code>，在文件夹中启动<code>cmd</code>,创建package.json，在package.json中必须有写入</p><pre><code>{  &quot;name&quot;: &quot;app&quot;,  &quot;main&quot;: &quot;main.js&quot;,}</code></pre><p>在app文件夹中创建<code>main.js</code>文件，在文件中写入以下内容</p><pre><code class="js">const { app, BrowserWindow } = require(&#39;electron&#39;)const path = require(&#39;path&#39;)const url = require(&#39;url&#39;)// 保持一个对于 window 对象的全局引用，不然，当 JavaScript 被 GC，// window 会被自动地关闭var mainWindow = null;// 当所有窗口被关闭了，退出。app.on(&#39;window-all-closed&#39;, function () {    // 在 OS X 上，通常用户在明确地按下 Cmd + Q 之前    // 应用会保持活动状态    if (process.platform != &#39;darwin&#39;) {        app.quit();    }});// 当 Electron 完成了初始化并且准备创建浏览器窗口的时候// 这个方法就被调用app.on(&#39;ready&#39;, function () {    // 创建浏览器窗口。    mainWindow = new BrowserWindow({ width: 800, height: 600 });    // 加载应用的 index    mainWindow.loadURL(&quot;http://www.baidu.com&quot;)    // 打开开发工具    // mainWindow.openDevTools();    // 当 window 被关闭，这个事件会被发出    mainWindow.on(&#39;closed&#39;, function () {        // 取消引用 window 对象，如果你的应用支持多窗口的话，        // 通常会把多个 window 对象存放在一个数组里面，        // 但这次不是。        mainWindow = null;    });});</code></pre><p>如果安装了上边说的 <code>npm install electron -g</code>，就可以直接在命令窗口运行<code>electron .</code>,打开窗口了</p><h2 id="导出文件"><a href="#导出文件" class="headerlink" title="导出文件"></a>导出文件</h2><p>在app文件夹下，安装</p><p><code>npm install electron -D</code></p><p><code>npm install electron-package -D</code></p><br/>安装后，在命令行输入`electron-packager . app --win --out ./appBox --arch=x64 --version1.0.0 --icon=ico.ico --overwrite --ignore=node_modules`<p>这句命令的意思是<code>electron-packager .</code>exe文件名称<code>--win --out ./</code>文件夹名称<code>--arch=</code>64位<code>--version</code>版本号<code>--icon=</code>打包后文件的图标<code>--</code>每次调用覆盖文件<code>--ignore=</code>不打包的内容</p><p>可以按照个人需求适当删除内容</p><p><em>注意：</em> <code>electron-packager</code>必须安装<strong>Powershell3或3以上版本</strong>和<strong>NET4.5或4.5以上版本</strong>，否则会报错</p><hr><p>如果希望打开内容不是一个<code>URL</code>而是一个<code>index.html</code>的本地文件的话，可以使用</p><pre><code class="js">// 把mainWindow.loadURL(&quot;http://www.baidu.com&quot;)// 替换为mainWindowloadURL(url.format({    pathname: path.join(__dirname, &#39;index.html&#39;),    protocol: &#39;file:&#39;,    slashes: true}))</code></pre><p>然后在app文件夹中创建<code>index.html</code>就可以了</p><br/><p>如果需要打开后全屏显示</p><pre><code class="js">// 把mainWindow = new BrowserWindow({ width: 800, height: 600 });// 替换为mainWindow = new BrowserWindow({show: false, autoHideMenuBar: true})  mainWindow.maximize()  mainWindow.show()</code></pre><br/><p>如果需要删除掉顶部的菜单栏</p><pre><code class="js">// 把mainWindow = new BrowserWindow({ width: 800, height: 600 });// 替换为mainWindow = new BrowserWindow({width: 800, height: 600, autoHideMenuBar: true})</code></pre><hr><p>打包完成后，打开文件夹中的app.exe就可以运行了</p><p><img src="/blog-img/19-1.jpg" alt="app.exe文件图片"></p><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>现在已经可以使用了，但是我们的需求是制作成<code>一个</code>可运行的文件，可以采用把文件夹制作成自解压程序的方式解决这个问题</p><h3 id="做成单个的执行文件"><a href="#做成单个的执行文件" class="headerlink" title="做成单个的执行文件"></a>做成单个的执行文件</h3><p>现在的文件夹<br><img src="/blog-img/19-2.jpg" alt="现在的文件夹"></p><ol><li>右键已经打包好的文件夹（app-win32-x64），添加到压缩文件，在 常规 选项卡中选择 创建自解压格式压缩文件 （不同的压缩文件按钮的位置可能会不同）</li></ol><p><img src="/blog-img/19-3.jpg" alt="常规"></p><ol start="2"><li>在 高级 选项卡中点击 自解压选项 ，在 设置 选项卡中设置 提取后运行 ，输入app.exe的路径</li></ol><p><img src="/blog-img/19-4.jpg" alt="高级"></p><ol start="3"><li>在 模式 选项卡中点击 解包到临时文件夹 静默模式 选择 全部隐藏</li></ol><p><img src="/blog-img/19-5.jpg" alt="模式"></p><ol start="4"><li>在 更新 选项卡中 覆盖方式 选择 覆盖所有文件</li></ol><p><img src="/blog-img/19-6.jpg" alt="更新"></p><ol start="5"><li><p>在 文本和图标中可以自定义文件的图标等信息（就不放图了）</p></li><li><p>点击确定，开始创建压缩文件</p></li></ol><p>创建完成后，会生成一个exe文件，双击文件就可以打开了~</p><p><img src="/blog-img/19-7.jpg" alt="exe文件"></p><h3 id="做成安装包形式"><a href="#做成安装包形式" class="headerlink" title="做成安装包形式"></a>做成安装包形式</h3><p>做成单个的执行文件有一个致命的缺点，就是每次打开都相当于重新解压一次文件夹，运行速度缓慢，所以可以做成一个安装包（其实也是自解压格式）</p><ol><li>前两部和做成单个的执行文件一样，右键已经打包好的文件夹（app-win32-x64），添加到压缩文件，在 常规 选项卡中选择 创建自解压格式压缩文件 （不同的压缩文件按钮的位置可能会不同）</li></ol><p><img src="/blog-img/19-3.jpg" alt="常规"></p><ol start="2"><li>在 高级 选项卡中点击 自解压选项 ，在 设置 选项卡中设置 提取后运行 ，输入app.exe的路径</li></ol><p><img src="/blog-img/19-4.jpg" alt="高级"></p><ol start="3"><li>在 常规 选项卡中可以设置自解压路径，解压路径是设置的默认解压时解压在你设置的文件夹下<br>如果设置 在“Program Files”中创建 的话，安装时的默认路径会在C盘的Program Files中  </li></ol><p><img src="/blog-img/19-8.jpg" alt="常规"></p><ol start="4"><li>在 更新 选项卡中 覆盖方式 选择 覆盖所有文件</li></ol><p><img src="/blog-img/19-6.jpg" alt="更新"></p><ol start="5"><li>如果想自动创建桌面快捷方式的话，可以在 高级 选项卡中选中 请求管理员密码 ，并点击 添加快捷方式 按钮，在里边设置相应的参数（注意源文件名要加路径）</li></ol><p><img src="/blog-img/19-9.jpg" alt="高级"></p><ol start="6"><li>点击确定，开始创建压缩文件</li></ol><p>创建完成后，会生成一个exe文件，双击文件安装</p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> electron </tag>
            
            <tag> 其他问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象与数组遍历</title>
      <link href="/2020-03-13-18.html"/>
      <url>/2020-03-13-18.html</url>
      
        <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>for、forEach、map、filter…</p><div style="display: none;">for of 便利出来的是value而不是key</div><h3 id="forEach的第二个参数"><a href="#forEach的第二个参数" class="headerlink" title="forEach的第二个参数"></a>forEach的第二个参数</h3><p><code>Array.forEach(function(item){...},ArrayThis)</code></p><p>传入<code>forEach</code>的第二个参数会让function的this指向改变为第二个参数（第一个function如果为箭头函数的话则不会生效）</p><pre><code class="js">var a = [1,2]a.forEach(function(item){console.log(&#39;this为--&#39;, this)},a)// this为--[1,2]// this为--[1,2]a.forEach(function(item){console.log(&#39;this为--&#39;, this)},{})// this为--{}// this为--{}</code></pre><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p><code>Array.find(function(item){...},ArrayThis)</code></p><p>和filter相似，都是找到符合条件的值，但是find只返回第一个符合条件的属性</p><h3 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex"></a>findIndex</h3><p><code>Array.findIndex(function(item){...})</code></p><p>查找是否有符合条件的值，如果找到符合条件的值，停止执行，返回该值的index</p><h3 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h3><p><code>Array.includes(val)</code></p><p>判断数组中是否包含val，返回Boolean</p><pre><code class="js">var a = [1,2,3,4,5,6,7,8]a.includes(5)// true</code></pre><h3 id="every"><a href="#every" class="headerlink" title="every"></a>every</h3><p><code>Array.every(item =&gt; {...})</code></p><p>检测数组中的值是否符合条件，如果其中一个为false，则停止检测，返回false</p><pre><code class="js">var a = [1,2,3,4]console.log(    a.every(item =&gt; {        return item &gt; 3    }))// false</code></pre><h3 id="some"><a href="#some" class="headerlink" title="some"></a>some</h3><p><code>Array.some(item =&gt; {...})</code></p><p>检测数组中的值是否符合条件，如果去中一个为true，则停止检测则返回true</p><pre><code class="js">var a = [1,2,3,4]console.log(    a.some(item =&gt; {        return item &gt; 3    }))// true</code></pre><h3 id="reduce-reduceRight"><a href="#reduce-reduceRight" class="headerlink" title="reduce / reduceRight"></a>reduce / reduceRight</h3><p><code>Array.reduce((a,b) =&gt; a + b)</code></p><p>将数组中的每个值以从左到右的顺序累加（reduceRight是从右向左），最终返回一个值</p><ul><li>function中有四个参数，分别为<code>([上一次的值],[当前值],[当前的index],[原数组])</code></li><li>Array.reduce有第二个参数，值为第一次相加前的初始值</li></ul><pre><code class="js">var a = [1,2,3,4,5]var b = a.reduce((a, b) =&gt; {    return a + b},100)// 115</code></pre><h2 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h2><p>for in、for of…</p><h3 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys"></a>Object.keys</h3><p><code>Object.keys(obj)</code></p><p>返回一个数组，数组中包括对象obj中的所有（可枚举）属性名称</p><pre><code class="js">a = {a: 1, b: 2, c: 3, d: 4}Object.keys(a)// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</code></pre><h3 id="getOwnPropertyNames"><a href="#getOwnPropertyNames" class="headerlink" title="getOwnPropertyNames"></a>getOwnPropertyNames</h3><p><code>Object.getOwnPropertyNames(obj)</code></p><p>返回一个数组，数组中包括对象obj中的所有（包括不可枚举）属性名称</p><h3 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values"></a>Object.values</h3><p><code>Object.values(obj)</code></p><p>以对象的形式返回数组</p><pre><code class="js">a = {a: 1, b: 2, c: 3, d: 4}Object.values(a)// [1, 2, 3, 4]</code></pre><h2 id="对对象数组的单个属性去重"><a href="#对对象数组的单个属性去重" class="headerlink" title="对对象数组的单个属性去重"></a>对对象数组的单个属性去重</h2><pre><code class="js">var a = [{    name: &#39;小明&#39;,    age: 20,    team: &#39;小明团队&#39;},{    name: &#39;小红&#39;,    age: 15    team: &#39;小红团队&#39;},{    name: &#39;小白&#39;,    age: 18    team: &#39;小白团队&#39;},{    name: &#39;小绿&#39;,    age: 99    team: &#39;小彩团队&#39;},{    name: &#39;小彩&#39;,    age: 24    team: &#39;小彩团队&#39;}]let newA = a.filter((item,index,arr) =&gt; {    return arr.findIndex(arrItem =&gt; arrItem.team === item.team) === index})</code></pre><p>利用了findIndex从左到右查找的机制，在数组中<code>team</code>有重复的的情况下，如果<code>findIndex</code>查找得出的<code>index</code>不等于<code>filter</code>当前的<code>index</code>的话，则代表着<code>arrItem</code>在这个数组之前的属性中存在过了，<code>filter</code>返回<code>false</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器问题</title>
      <link href="/2020-03-02-17.html"/>
      <url>/2020-03-02-17.html</url>
      
        <content type="html"><![CDATA[<h2 id="重绘和回流"><a href="#重绘和回流" class="headerlink" title="重绘和回流"></a>重绘和回流</h2><p>网页主要由三部分组成：结构（Structure）（HTML）、表现（Presentation）（CSS）和行为（Behavior）（JS）。</p><h3 id="浏览器渲染"><a href="#浏览器渲染" class="headerlink" title="浏览器渲染"></a>浏览器渲染</h3><p>DOM树: 浏览器把获取到的html代码解析成1个Dom树，html中的每个节点（tag）都是Dom树中的1个节点，根节点是document对象 。dom树里面包含了所有的html标签，包括display:none隐藏，还有用JS动态添加的元素等</p><p>CSSOM树： CSS加载完之后对CSS进行解析，解析成CSS对象，然后把CSS对象组装起来，构建CSSOM树（个人理解：纯CSS的树）</p><p>渲染树(render tree): 将DOM树和CSSOM树结合起来的树，树种的每个“节点”都有自己的style，该树只包含了用于渲染页面的节点（不包含display: none的节点和head节点），不影响呈现画面的节点不会被包括到渲染树中。</p><h3 id="回流（重排）"><a href="#回流（重排）" class="headerlink" title="回流（重排）"></a>回流（重排）</h3><p>渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流。每个页面至少需要一次回流，就是在页面第一次加载的时候。</p><h3 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h3><p>渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。</p><p><strong>回流必将引起重绘，而重绘不一定会引起回流。</strong></p><h2 id="URL-输入到渲染的过程"><a href="#URL-输入到渲染的过程" class="headerlink" title="URL 输入到渲染的过程"></a>URL 输入到渲染的过程</h2><ol><li>DNS 解析</li><li>TCP 连接</li><li>HTTP 请求抛出</li><li>服务端处理请求，HTTP 响应返回</li><li>浏览器拿到响应数据，解析响应内容，把解析的结果展示给用户</li></ol><div style="display: none;">域名解析，找到服务地址  构建 TCP 连接，若有 https，则多一层 TLS 握手，  特殊响应码处理 301 302  *是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错。*  解析文档  构建 dom 树和 csscom  生成渲染树：从DOM树的根节点开始遍历每个可见节点，对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们，根据每个可见节点以及其对应的样式，组合生成渲染树  Layout（回流）：根据生成的渲染树，进行回流（Layout），得到节点的集合信息  Painting（重绘）：根据渲染树及其回流得到的集合信息，得到节点的绝对像素。  绘制，在页面上展示，这一步还涉及到绘制层级、GPU相关的知识点  加载js脚本，加载完成解析js脚本  </div><h2 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h2><p>http 是建立在 TCP 上的应用层协议，超文本传输协议。</p><p>要了解http协议，首先要了解TCP是什么</p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>tcp 是传输层协议，它的特点是：三次握手和四次挥手。</p><p>三次握手目的是为了防止已经失效的连接请求报文段突然又传到服务端，而产生错误</p><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>1、客户端发送随机产生的数据到服务器，要求建立连接（<em>客户端</em> 向 <em>服务端</em> 请求连接）</p><p>2、服务端收到请求后确认信息，向客户端返回生成的相应数据（<em>服务端</em> 向 <em>客户端</em> 返回，同意连接）</p><p>3、客户端收到返回的数据后检查确认是不是第一步（1）中发送的链接，如果正确，客户端会发送数据，链接成功</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>1、客户端发送请求给服务端，要求断开链接，同时进入等待状态，不再发送数据，但是会接收数据</p><p>2、服务端收到后，向客户端发送信息，告诉客户端收到了，然后也进入等待状态，不再接收数据，但是会发送数据</p><p>3.服务端发送完剩余的数据后，向客户端发送信息，告知客户端可以断开了，然后服务端不再接收和发送数据</p><p>4、客户端收到后，释放链接，并向服务端发送数据，告诉服务端也释放链接</p><h3 id="http协议-1"><a href="#http协议-1" class="headerlink" title="http协议"></a>http协议</h3><p>是单向的短链接，目前有 http1.0 http 1.1 http2.0</p><p>http1.0 :客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。</p><p>http1.1 :可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求</p><p>http2.0 :可支持多路复用，一个 tcp 可同时传输多个 http 请求，头部数据还做了压缩</p><h2 id="https协议"><a href="#https协议" class="headerlink" title="https协议"></a>https协议</h2><p>http 报文传输过程中是明文的，可以通过抓包的方式看到报文内容，这就暴露一个安全问题，易被劫持篡改。</p><p>为了解决这个问题，就有了TLS，http + TLS = https</p><p>LS：安全传输层协议，用于在两个通信应用程序之间提供保密性和数据完整性，该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。</p><p>TLS 利用非对称加密演算来对通信方做身份认证，之后交换对称密钥作为会谈密钥（Session key）,因此 https 分为两个阶段</p><ol><li>通过非对称加解密确认对方身份是否合法，若合法生成会话密钥。（这一步是核心）</li><li>报文的在发送前，先用会话密钥进行对称加密，在传输。</li></ol><h3 id="TLS-握手"><a href="#TLS-握手" class="headerlink" title="TLS 握手"></a>TLS 握手</h3><p>步骤如下：</p><ol><li>客户端请求服务端建立SSL链接，服务端并向客户端发送一个随机数 randomC 和 CA 机构颁发的证书</li><li>客户端对证书进行验证，验证通过后，生成一个随机数 randomS ，用公钥对 randomS 加密 ，同时用 randomS 生成一段签名，发送给服务端</li><li>服务端接收到后，用私钥对秘文解密，用解密后的 key 生成签名，并与客户端传来的签名进行比较，检验通过后，然后生成一个随机数 randomP ，并用私钥加密，还有随机数生成的 hash 值，一并发给客户端。</li><li>客户端用公钥解密，并校验 hash 值通过后，两端利用 randomC randomS randomP 通过一定的算法生成 session key，后续的报文将通过 session key 对称加密进行传输。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise、Generator、async/await用法</title>
      <link href="/2020-01-09-16.html"/>
      <url>/2020-01-09-16.html</url>
      
        <content type="html"><![CDATA[<p>Promise、Generator、async/await都是用来解决异步编程的</p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><pre><code class="js">    new Promise((resolve,reject) =&gt; {        if (...) {            resolve()        } else {            reject()        }    }).then(res =&gt; {        ...    }).catch(err =&gt; {        ...    })</code></pre><p>promise对象一共有三个状态</p><ul><li>等待 </li><li>实现(resolve)</li><li>失败(reject)</li></ul><p>从创建开始，promise对象的状态就是等待的状态，直到<code>resolve</code>和<code>reject</code>被调用</p><p>当promise被变成resolve时，会触发<code>then()</code>里的函数</p><p>当promise被变成reject时，会触发<code>catch()</code>里的函数 <em>(也可以将<code>err=&gt;{...}</code>写在then中，当做then的第二个形参传入，在<code>reject</code>时也会触发)</em></p><h3 id="promise-all"><a href="#promise-all" class="headerlink" title="promise.all()"></a>promise.all()</h3><p><code>promise.all()</code> 用于对多个promise打包成一个新的promise</p><p><strong>promise.all接受一个数组，数组中是promise对象或其他值，当调用时，如果数组中有任何一个promise对象失败（reject），promise.all都会失败，走catch(有resolve的也会同时走then)，返回值是失败的reject返回的信息</strong></p><pre><code class="js">var a = function () {    new Promise((resolve, reject) =&gt; {        setTimeout(() =&gt; reject(&#39;这是错误返回信息&#39;), 1000)    })}var b = function () {    return new Promise((resolve, reject) =&gt; {        setTimeout(() =&gt; resolve(&#39;正确1&#39;), 1000)    })}var c = function () {    return new Promise((resolve, reject) =&gt; {        setTimeout(() =&gt; resolve(&#39;正确2&#39;), 1000)    })}Promise.all([c(), b(), a()]).then(res =&gt; {    console.log(res)}).catch(err =&gt; {    console.error(err)})</code></pre><p>得到结果<br><img src="/blog-img/16-1.jpg" alt="输出的log"></p><p><code>Promise.all</code>会同时执行all中所有的promise对象，然后按顺序返回回来，所以<em>上放代码调用时，用时1s多，并不是3s多</em></p><h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><p>Generator函数是一个可以“暂停”的函数写法，可以通过对函数内部设置 “暂停”按钮 返回一个值并暂停函数执行，直到让他“开始”</p><p>Generator函数的创建方法是在函数后边添加一个<code>*</code></p><pre><code class="js">function * fun () {    ...    yield xxx    ...    return xxx}// 或var fun2 = function * () {    ...    yield xxx    ...    return xxx}</code></pre><p>在调用Generator函数时，并不会直接出发该函数，而是返回一个Generator对象，然后，通过<code>Generator对象.next()</code>来执行函数</p><ul><li>“暂停”按钮： 在执行到yield的时候，会暂停该函数，并“return”出<code>yield</code>的内容，直到下次执行<code>next()</code></li><li>“开始”按钮： 通过<code>next()</code>执行函数</li><li><code>next()</code>返回值是一个对象，对象包含<code>value</code>和 <code>done</code> </li><li><ul><li>value: 返回的值</li></ul></li><li><ul><li>done: Boolean值，如果为false，代表着是<code>yield</code>输出,还没有<code>return</code>(无论yield后函数中还有没有代码，都会返回false)，如果为true，代表着此次输出是<code>return</code>或已经结束</li></ul></li></ul><pre><code class="js">function * fun () {    yield &#39;xxx1&#39;    yield &#39;xxx2&#39;    yield &#39;xxx3&#39;    yield &#39;xxx4&#39;    return &#39;x&#39;}var a = fun()a.next()a.next()a.next()a.next()a.next()a.next()// {value: &quot;xxx1&quot;, done: false}// {value: &quot;xxx2&quot;, done: false}// {value: &quot;xxx3&quot;, done: false}// {value: &quot;xxx4&quot;, done: false}// {value: &quot;x&quot;, done: true}// {value: undefined, done: true}</code></pre><p>在<code>next()</code>中可以传值</p><pre><code class="js">function * fun () {    var a = yield &#39;函数中的字符串&#39;    console.log(&#39;log出来的内容： &#39; + a)    return a}var a = fun()a.next()a.next() // {value: &quot;函数中的字符串&quot;, done: false} // log出来的内容： 传输的字符串 // {value: &quot;传输的字符串&quot;, done: true}</code></pre><h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><p>async/await是一种处理promise的及其简便的方法</p><p>async函数返回的是一个promise对象，在async函数中，碰到<code>await</code>会等待，等待<code>await</code>后边的<strong>表达式</strong>的计算结果完成，这个表达式的计算结果可以是<code>promise</code>或者其他值（因为await可以等待表达式结果，所以可以等待<code>react</code>中的<code>setState({})</code>）</p><pre><code class="js">async function fun () {    await new Promise(resolve =&gt; {setTimeout(()=&gt; resolve(&#39;111&#39;), 1000)})    console.log(&#39;111&#39;)    return &#39;return值&#39;}fun()// ... 1秒后// 111fun().then(res =&gt; {console.log(res)})// ... 1秒后// 111// return值</code></pre><p>await可以和promise.all同时使用</p><pre><code class="js">function promiseFun1 () {    return new Promise(resolve =&gt; setTimeout(resolve, 1000))}function promiseFun2 () {    return new Promise(resolve =&gt; setTimeout(resolve, 1000))}function promiseFun3 () {    return new Promise(resolve =&gt; setTimeout(resolve, 1000))}function promiseFun4 () {    return new Promise(resolve =&gt; setTimeout(resolve, 1000))}async function runner () {    return Promise.all([promiseFun1(), promiseFun2(), promiseFun3(), promiseFun4()])}async function go () {    await runner()    await console.log(1)}go()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-router嵌套路由中无父级组件的设置方法</title>
      <link href="/2020-01-08-15.html"/>
      <url>/2020-01-08-15.html</url>
      
        <content type="html"><![CDATA[<p>解决方法： <code>component: {render: (e) =&gt; e(&quot;router-view&quot;)},</code></p><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>在一些情况下，会有设置二级路由，但一级路由不需要 <code>component</code> 的特殊需求</p><p><em>比如我在data路由下需要List页<code>.../#/data/list</code>，shop页<code>.../#/data/shop</code> 等，但每一个页面中没有任何相同的地方，也就是在<code>.../#/data</code>路由下不需要<code>component</code></em></p><p>如下路由</p><pre><code class="js">[{    path: &#39;/data&#39;,    name: &#39;data&#39;,    meta: {        name: &#39;data页&#39;,        auth: true,        icon: &#39;icon-account&#39;    },    component: Data, // 需求是这里引入为空，但children中的component还会有东西    children: [{        path: &#39;list&#39;,        name: &#39;list&#39;,        meta: {            name: &#39;列表页&#39;,            auth: true        },        component: List,    }, {        path: &#39;shop&#39;,        name: &#39;shop&#39;,        meta: {            name: &#39;商店页&#39;,            auth: true        },        component: Shop    }, {        path: &#39;detail&#39;,        name: &#39;detail&#39;,        meta: {            name: &#39;查看&#39;,            auth: true        },        component: Detail    }]}]</code></pre><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>在<code>/data</code>中，如果不写<code>component</code> 属性,子集的component也不会显示</p><ol><li>新建一个页面，在页面中写<pre><code class="HTML">&lt;template&gt; &lt;router-view /&gt;&lt;/template&gt;</code></pre>然后<code>component: 上边那个页面</code></li><li>可以将<code>component</code> 写成<code>component: {render: (e) =&gt; e(&quot;router-view&quot;)},</code></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react配置导入根路径</title>
      <link href="/2019-12-31-13.html"/>
      <url>/2019-12-31-13.html</url>
      
        <content type="html"><![CDATA[<h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h4><p>react配置导入根路径需要在webpack中配置，但使用脚手架创建的项目，默认将<code>babel</code>、<code>webpack</code>等内容全部封装到<code>react-scripts</code>中，所以在这种状态下没有办法更改<code>webpack</code>中的内容</p><p>需要执行<code>npm run eject</code>解开<code>react-scripts</code>包</p><ul><li><code>npm run eject</code> 命令无法撤销</li><li>执行后，会出现<code>config</code> 和<code>scripts</code> 两个文件夹</li></ul><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>在新出现的<code>config</code> 文件夹中，找到 <code>webpack.config.js</code> 文件，在<code>alias</code> 中插入<code>&#39;@&#39;: path.resolve(&#39;src&#39;),</code>就可以了</p><pre><code class="js">alias: {        &#39;@&#39;: path.resolve(&#39;src&#39;),        // Support React Native Web        // https://www.smashingmagazine.com/2016/08/a-glimpse-into-the-future-with-react-native-for-web/        &#39;react-native&#39;: &#39;react-native-web&#39;,        // Allows for better profiling with ReactDevTools        ...(isEnvProductionProfile &amp;&amp; {          &#39;react-dom$&#39;: &#39;react-dom/profiling&#39;,          &#39;scheduler/tracing&#39;: &#39;scheduler/tracing-profiling&#39;,        }),        ...(modules.webpackAliases || {}),      },</code></pre><p>在以后引入时，<code>#</code>代表的就是 <code>根目录/src</code> 了</p>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react插槽</title>
      <link href="/2019-12-31-14.html"/>
      <url>/2019-12-31-14.html</url>
      
        <content type="html"><![CDATA[<h2 id="单个插槽"><a href="#单个插槽" class="headerlink" title="单个插槽"></a>单个插槽</h2><p>假设有一个名为<code>Box</code>的子组件</p><pre><code class="jsx">...&lt;Box&gt;    &lt;div&gt;123123&lt;/div&gt;&lt;/Box&gt;...// 在子组件中    ...    render() {        return (            &lt;div&gt;                &lt;div&gt;xxx....&lt;/div&gt;                {this.props.children}            &lt;/div&gt;         )    }    /** 输出     * &lt;div&gt;xxx....&lt;/div&gt;     * &lt;div&gt;123123&lt;/div&gt;     */</code></pre><h2 id="多个插槽"><a href="#多个插槽" class="headerlink" title="多个插槽"></a>多个插槽</h2><p>在父级的子组件节点(<code>&lt;Box&gt;...&lt;/Box&gt;</code>)中，写多个<code>div</code> 就是多个插槽，在子组件中，<code>this.props.children</code> 是一个数组，直接写<code>this.props.children</code>的话会把所有的插槽都放在节点上</p><pre><code class="jsx">...&lt;Box&gt;    &lt;div&gt;123123&lt;/div&gt;    &lt;div&gt;aaabbbccc&lt;/div&gt;&lt;/Box&gt;...// 在子组件中    ...    render() {        return (            &lt;div&gt;                &lt;div&gt;xxx....&lt;/div&gt;                {this.props.children}            &lt;/div&gt;         )    }    /** 输出     * &lt;div&gt;xxx....&lt;/div&gt;     * &lt;div&gt;123123&lt;/div&gt;     * &lt;div&gt;aaabbbccc&lt;/div&gt;     */</code></pre><p>因为<code>this.props.children</code>是一个数组，如果想要区分开，可以使用<code>{this.props.children[0]}</code></p><pre><code class="jsx">    ...    render() {        return (            &lt;div&gt;                &lt;div&gt;xxx....&lt;/div&gt;                {this.props.children[1]}            &lt;/div&gt;         )    }    /** 输出     * &lt;div&gt;xxx....&lt;/div&gt;     * &lt;div&gt;aaabbbccc&lt;/div&gt;     */</code></pre><p>也可以将插入的div添加个标识符</p><pre><code class="jsx">...&lt;Box&gt;    &lt;div ref=&quot;title&quot; name=&quot;title&quot;&gt;111&lt;/div&gt;    &lt;div ref=&quot;content&quot; name=&quot;content&quot;&gt;222&lt;/div&gt;&lt;/Box&gt;...</code></pre><p>我们会发现，组件中接收的值有ref和name属性(用别的属性也可以，在这里只是用ref和name举一个栗子)<br><img src="/blog-img/14-1.jpg" alt="输出的log"></p><p>在使用时候，可以直接输出<code>this.props.children.filter(item =&gt; item.ref === &#39;content&#39;)</code>就可以得到想要的了</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>在插槽子组件中使用<code>filter</code> 时有一个坑，就是我们做组件时，插槽的位置是可填可不填的，而在react中如果只填写一个插槽的话，<code>this.props.children</code> 并不是一个数组，所以会导致<code>filter</code> 报错</p><p>可以在输出时写成这种方式：</p><pre><code class="jsx">...{this.props.children &amp;&amp; this.props.children.length ? this.props.children.filter(item =&gt; item.ref === &#39;content&#39;) : this.props.children}...</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redux学习笔记</title>
      <link href="/2019-12-27-12.html"/>
      <url>/2019-12-27-12.html</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><pre><code>redux是对于flux的完美实现，redux和react搭配很完美，但是redux是独立的，并不是基于react使用的</code></pre><p>Redux 的工作流程<br><img src="/blog-img/12-1.png" alt="redux"></p><p><strong>以下仅为个人理解，可能不准确（从store向下开始）</strong>  </p><ul><li><code>store</code> 是个容器，用于储存数据(state)，只能有一个store</li><li><code>state</code> 数据，某个状态下的数据  </li><li><code>react Component</code> 组件，通过操作执行 <code>action creators</code></li><li><code>action</code> <code>react Component</code>中的操作，<code>react Component</code>中无法直接获取和修改<code>state</code>，要通过<code>action</code>修改（改变state的唯一方式是通过触发action来修改）</li><li><code>dispatch(action)</code> <code>view</code>发出<code>action</code>的方法，他接受一个形参，形参的值为描述<code>action</code>的动作（只发出，不是接受）</li><li><code>previousState,action</code> store接收到 <code>action</code> 后，调用 <code>reducer</code> 传入 <code>previousState,action</code> （老状态和action），执行reduces</li><li><code>reducers</code> 通过<code>store</code>  接收 <code>action</code> ，然后根据 <code>action</code> 返回新的<code>state</code></li><li><code>newState</code> 返回的新的state， <code>view</code> 层通过 <code>store.getState</code> 获取新的 <code>state</code></li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>npm install --save redux react-redux</code></pre><h2 id="创建基础store文件"><a href="#创建基础store文件" class="headerlink" title="创建基础store文件"></a>创建基础store文件</h2><p>引入<code>redux</code>中的<code>createStore</code>，通过他创建<code>store</code>文件</p><pre><code class="jsx">import { createStore } from &quot;redux&quot;;const store = createStore(reducer); // reducer在下边代码块中会演示创建export default store;</code></pre><p>然后创建<code>reducer</code>,<code>reducer</code>为store中要存储的数据（是一个<code>function</code>）</p><pre><code class="jsx">function reducer(state = 0, action) {    if (action.type !== &quot;reducer&quot;) return state    return action.payload ? action.payload : state}</code></pre><p><code>state</code> 为存储的数据(上一次传入的值，如果是第一次获取state，默认为0)<br><code>action</code> 为调用<code>function</code> 传入的参数</p><p><strong><code>store.js</code>文件整体代码</strong></p><pre><code class="jsx">import { createStore } from &quot;redux&quot;;function reducer(state = 0, action) {    if (action.type !== &quot;reducer&quot;) return state    return action.payload ? action.payload : state}const store = createStore(reducer); // reducer在下边代码块中会演示创建export default store;</code></pre><h2 id="获取数据-getState"><a href="#获取数据-getState" class="headerlink" title="获取数据 (getState)"></a>获取数据 (getState)</h2><p>在使用时，需要在页面中先引入<code>store</code>文件，然后通过<code>getState</code>获取到<code>store</code>中的数据</p><pre><code class="jsx">import store from &quot;../store/store.js&quot;...function getStore () {    console.log(store.getState())}...</code></pre><h2 id="Action触发-dispatch"><a href="#Action触发-dispatch" class="headerlink" title="Action触发 (dispatch)"></a>Action触发 (dispatch)</h2><p>通过dispatch触发Action来改变store中存储的值</p><pre><code class="jsx">import store from &quot;../store/store.js&quot;...function setStore () {    store.dispatch({        type: &quot;reducer&quot;,        payload: 10    })}// store.getState() // 10</code></pre><h2 id="多任务方法-combineReducers"><a href="#多任务方法-combineReducers" class="headerlink" title="多任务方法 (combineReducers)"></a>多任务方法 (combineReducers)</h2><p>按照上边方法，redux只能存储一个值，如果想存储多个，需要 <code>combineReducers</code> 调用一下</p><pre><code class="jsx">import { createStore, combineReducers } from &quot;redux&quot;; // 需要引入 combineReducersfunction reducer(state = 0, action) {    if (action.type !== &quot;reducer&quot;) return state    return action.payload ? action.payload : state}function counter(state = 0, action) {  if (action.type !== &quot;counter&quot;) return state  return action.payload ? state + action.payload : state}// const store = createStore(reducer); // 之前的写法const store = combineReducers({    reducer,    counter})export default store;</code></pre><h2 id="redux中间件-applyMiddleware"><a href="#redux中间件-applyMiddleware" class="headerlink" title="redux中间件 (applyMiddleware)"></a>redux中间件 (applyMiddleware)</h2><p><code>applyMiddleware</code> 是redux插件默认带的一种方法，为store添加中间件。</p><p><code>applyMiddleware</code>将所有中间件组成一个数组，依次执行</p><pre><code class="jsx">export default function applyMiddleware(...middlewares) {  return (createStore) =&gt; (reducer, preloadedState, enhancer) =&gt; {    var store = createStore(reducer, preloadedState, enhancer);    var dispatch = store.dispatch;    var chain = [];    var middlewareAPI = {      getState: store.getState,      dispatch: (action) =&gt; dispatch(action)    };    chain = middlewares.map(middleware =&gt; middleware(middlewareAPI));    dispatch = compose(...chain)(store.dispatch);    return {...store, dispatch}  }}//执行顺序解析//中间件数组传入{getState: store.getState,dispatch: (action) =&gt; dispatch(action)} =&gt; //compose合并新中间件数组 并传入dispatch=&gt;//执行完所有中间件函数后返回store和dispatch</code></pre><p><code>applyMiddlewares</code> 返回的是<code>store</code> 对象</p><p><em><a href="https://blog.csdn.net/qdmoment/article/details/84024611" target="_blank" rel="noopener">部分摘录：CSDN博主qdmoment</a></em></p><h2 id="异步处理-redux-thunk"><a href="#异步处理-redux-thunk" class="headerlink" title="异步处理 (redux-thunk)"></a>异步处理 (redux-thunk)</h2><p>通过<code>react-thunk</code> 可以进行异步处理</p><p>安装 <code>npm i --save redux-thunk</code></p><pre><code class="jsx">import thunk from &#39;redux-thunk&#39; // 引入...var store = createStore(rReducers, applyMiddleware(thunk)) // 注册export default store</code></pre><p>异步组件书写方法和同步组件类似，如果是异步，需要返回一个promise对象</p><pre><code class="jsx">function strCounter(state = &#39;aaa&#39;, action) {    if (action.type !== &quot;strCounter&quot;) return state    if (action.payload) {        var data = new Promise((resolve, reject) =&gt; {        setTimeout(() =&gt; {            return &#39;2222&#39;        },10000)        })        return data    } else {        return state    }}</code></pre><p><code>react-thunk</code> 源码</p><pre><code class="jsx">function createThunkMiddleware(extraArgument) {  return ({ dispatch, getState }) =&gt; next =&gt; action =&gt; {    if (typeof action === &#39;function&#39;) {      return action(dispatch, getState, extraArgument);    }    return next(action);  };}const thunk = createThunkMiddleware();thunk.withExtraArgument = createThunkMiddleware;export default thunk;</code></pre><p>源码来源：<a href="https://www.jianshu.com/p/a3b9b0958aeb" target="_blank" rel="noopener">简书博主zhangwang</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react引入element-UI报错</title>
      <link href="/2019-12-25-11.html"/>
      <url>/2019-12-25-11.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>初学react，按照官网的方式引入element-UI后，控制台报一下错误</p><pre><code>Module not found: Can&#39;t resolve &#39;react-hot-loader&#39; in &#39;xxxnode_modules\element-react\dist\npm\es5\libs\animate&#39;</code></pre><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>安装最新版 <code>react-hot-loader</code> 后解决问题</p><pre><code>npm install react-hot-loader@next --save</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-router-dom学习笔记</title>
      <link href="/2019-12-23-10.html"/>
      <url>/2019-12-23-10.html</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>npm install react-router-dom --save-dev</code><br><em><code>react-router-dom</code>会自动安装依赖<code>react-router</code></em></p><h2 id="创建路由"><a href="#创建路由" class="headerlink" title="创建路由"></a>创建路由</h2><h3 id="1-创建router-js"><a href="#1-创建router-js" class="headerlink" title="1. 创建router.js"></a>1. 创建router.js</h3><pre><code class="jsx">import React from &#39;react&#39;;import { BrowserRouter, Route, Switch } from &#39;react-router-dom&#39;;import App from &quot;../view/App&quot;;import Home from &#39;../view/home&#39;;import Detail from &#39;../view/detail&#39;;import Store from &#39;../view/store&#39;;const Router = (    &lt;BrowserRouter&gt;        &lt;App&gt;            &lt;Switch&gt;                &lt;Route exact path=&quot;/&quot; component={Home}&gt;&lt;/Route&gt;                &lt;Route exact path=&quot;/detail&quot; component={Detail}&gt;&lt;/Route&gt;                &lt;Route exact path=&quot;/store/:id&quot; component={Store}&gt;&lt;/Route&gt;            &lt;/Switch&gt;        &lt;/App&gt;    &lt;/BrowserRouter&gt;)export default Router </code></pre><p>路由模式分为<code>BrowserRouter</code> (history模式) 和<code>HashRouter</code> (hash模式)</p><h3 id="2-入口JS文件修改"><a href="#2-入口JS文件修改" class="headerlink" title="2. 入口JS文件修改"></a>2. 入口JS文件修改</h3><p>将入口js文件中的App改为router.js文件</p><pre><code class="jsx">import ReactDOM from &#39;react-dom&#39;;import Router from &quot;./router&quot;ReactDOM.render(  Router, // 将默认的 &lt;app /&gt; 改为Router文件  document.getElementById(&#39;root&#39;));</code></pre><h3 id="3-路由容器"><a href="#3-路由容器" class="headerlink" title="3. 路由容器"></a>3. 路由容器</h3><p>在页面中使用<code>{this.props.children}</code>显示路由容器</p><h2 id="路由跳转"><a href="#路由跳转" class="headerlink" title="路由跳转"></a>路由跳转</h2><h3 id="声明式导航"><a href="#声明式导航" class="headerlink" title="声明式导航"></a>声明式导航</h3><p>声明式导航写在dom中，<code>&lt;NavLink to=&quot;/xxx&quot;&gt;跳转&lt;/NavLink&gt;</code>  </p><ul><li>声明式导航<code>NavLink</code>会默认在编译时被转换成<code>&lt;a&gt;</code>标签</li><li>通过<code>activeClassName</code>和<code>activeStyle={ {color: &#39;#fff&#39;} }</code>属性可以设置标签在选中时的样式和名称，默认样式名称为<code>active</code></li></ul><h3 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h3><p>用事件进行路由跳转</p><pre><code class="jsx">fun () {    this.props.history.push(&quot;/xxx&quot;)}</code></pre><h3 id="引入跳转"><a href="#引入跳转" class="headerlink" title="引入跳转"></a>引入跳转</h3><pre><code>import { browserHistory } from &quot;react-router&quot;;browserHistory.push(&quot;/xxx&quot;);</code></pre><h2 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h2><ol><li>/id 方式</li></ol><pre><code class="jsx">// 路由中...&lt;Route exact path=&quot;/store/:id&quot; component={Store}&gt;&lt;/Route&gt;...// 传参this.props.history.push(&#39;/store/xxx&#39;)// 取内容this.props.match.params.id</code></pre><ol start="2"><li>state方式<pre><code class="jsx">// 路由中&lt;Route exact path=&quot;/store&quot; component={Store}&gt;&lt;/Route&gt;</code></pre></li></ol><p>// 传参<br>this.props.history.push({<br>    pathname: “/store”,<br>    query: ‘bbb’<br>})</p><p>// 取内容<br>this.props.history.location.state</p><pre><code>## 重定向`Redirect` 重定向  ```jsximport { BrowserRouter, Route, Switch, Redirect } from &#39;react-router-dom&#39;;...&lt;Redirect from=&quot;/&quot; to=&quot;/film&quot;&gt;&lt;/Redirect&gt;...</code></pre><p><em>如果<code>from</code>匹配,则重定向到<code>to</code>页面</em></p><h2 id="二级路由"><a href="#二级路由" class="headerlink" title="二级路由"></a>二级路由</h2><pre><code class="jsx">&lt;Route path=&quot;/detail&quot; render={() =&gt; {    return (&lt;Detail&gt;        &lt;Route exact path=&quot;/detail/store&quot; component={Store}&gt;&lt;/Route&gt;    &lt;/Detail&gt;)}}&gt;&lt;/Route&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6-Proxy</title>
      <link href="/2019-12-18-9.html"/>
      <url>/2019-12-18-9.html</url>
      
        <content type="html"><![CDATA[<p>Proxy 代理 ，在我们访问对象前添加了一层拦截，可以过滤很多操作</p><pre><code>let a = new Proxy(target, handler);</code></pre><ul><li><code>target</code>: 需要包装的对象，可以是数组、函数、class类、Proxy等</li><li><code>handler</code>: 传入一个对象，对<code>target</code>进行的具体操作</li></ul><p>以Proxy的get示例</p><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><pre><code class="javascript">let obj = {    val: &#39;aaa&#39;}let proxyObj = new Proxy(obj,{    get(target, key) {        return target[key] + &#39;我被代理过了&#39;    }})console.log(proxyObj.val)// aaa我被代理过了</code></pre><p><em>创建一个obj，然后对其属性进行get监听，obj成为了proxyObj的实例，访问obj属性时，需要写proxyObj.xxx 这样就会被proxy拦截</em>  </p><p><strong>get可以对所有属性进行拦截，无论是已创建的还是未创建的</strong></p><pre><code class="javascript">// 接上一个例子...obj.b = &#39;bbb&#39;console.log(proxyObj.b)// bbb我被代理过了proxyObj.c// undefined我被代理过了proxyObj.c = &#39;ccc&#39;console.log(proxyObj.c)// ccc我被代理过了</code></pre><p><em>从上例中可以看出，无论是在obj中新赋值的属性，还是proxyObj中新赋值的属性，都可以被get监听到</em></p><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><pre><code class="javascript">const obj = {};const a = new Proxy(obj, {    set(target, prop, value){        target[prop] = value + &#39;我被代理过了&#39;;        // return true;    }})a.a = &#39;aaa&#39;;// aaaconsole.log(a.a)// aaa我被代理过了</code></pre><p><em>set可以监听目标对象的所有属性赋值行为。<strong>如果目标对象自身的某个属性是不可写也不可配置的，那么 set 不得改变这个属性的值，只能返回同样的值，否则报错。</strong></em></p><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><p>apply可以监听调用时的行为</p><pre><code class="javascript">var fun = function (a,b) {    return a + b}var a = new Proxy(fun, {    apply(target, thisArg, args) {        console.log(&#39;target&#39;, target)        console.log(&#39;thisArg&#39;, thisArg)        console.log(&#39;args&#39;, args)        return target.call(thisArg, ...args)    }})a(1,2)// &#39;target&#39; ƒ (a,b) { return a + b }// &#39;thisArg&#39; undefined// &#39;args&#39; [1, 2]// 3window.a(1,2)// &#39;target&#39; ƒ (a,b) { return a + b }// &#39;thisArg&#39; window {...}// &#39;args&#39; [1, 2]// 3</code></pre><p>apply中的参数  </p><ul><li><code>target</code> 原始的函数</li><li><code>thisArg</code> 调用时指向的this对象</li><li><code>args</code> 调用时取得的形参</li></ul><h2 id="construct"><a href="#construct" class="headerlink" title="construct"></a>construct</h2><p><code>construct</code>可以监听目标对象在new时的执行</p><pre><code class="javascript">class a {}var c = new Proxy(a, {    construct(target, args, newTarget) {        console.log(&#39;target&#39;, target)        console.log(&#39;args&#39;, args)        console.log(&#39;newTarget&#39;, newTarget)        return {args: args}    }})new c(1,2,3)// target class a {}// args [1, 2, 3]// newTarget Proxy {length: 0, prototype: {…}, name: &quot;a&quot;}// {args: Array(3)}</code></pre><p>construct中的参数和返回值  </p><ul><li><code>target</code> 原始的class类</li><li><code>args</code> 调用时取得的形参</li><li><code>newTarget</code> new target所得</li><li><code>return</code> 返回new所得到的实例</li></ul><h2 id="Proxy的其他属性"><a href="#Proxy的其他属性" class="headerlink" title="Proxy的其他属性"></a>Proxy的其他属性</h2><p>引自<a href="https://www.php.cn/js-tutorial-413686.html" target="_blank" rel="noopener">PHP中文网的不言</a>大神的博客</p><p><img src="/blog-img/9-1.jpg" alt="Proxy的其他属性"></p><h2 id="get、set监听时，Proxy和Object-definePrototype的区别"><a href="#get、set监听时，Proxy和Object-definePrototype的区别" class="headerlink" title="get、set监听时，Proxy和Object.definePrototype的区别"></a>get、set监听时，Proxy和Object.definePrototype的区别</h2><h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h3><ol><li>只能劫持对象的属性，如果属性也是对象需要深度便利</li><li>对数组监听，无法监听到他的变化</li><li>只能对对象中的单个属性监听</li><li>除了get、set，还有configurable、enumerable、value</li></ol><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><ol><li>Proxy需要创建一个新对象，监听后所有的操作需要在新对象上执行</li><li>会监听到对象中所有属性（可读写的）</li><li>除了get、set，还有apply、construct等很多属性</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-cli3+typescript初体验</title>
      <link href="/2019-12-17-8.html"/>
      <url>/2019-12-17-8.html</url>
      
        <content type="html"><![CDATA[<h2 id="生成项目"><a href="#生成项目" class="headerlink" title="生成项目"></a>生成项目</h2><pre><code>vue create ts-vue或vue ui // 可视化生成</code></pre><p>功能选择时把typescript勾上,安装完成后后<code>npm run serve</code>就可以了</p><h2 id="整体demo"><a href="#整体demo" class="headerlink" title="整体demo"></a>整体demo</h2><p><a href="https://github.com/vuejs/vue-class-component/blob/master/example/src/App.vue" target="_blank" rel="noopener">官方demo链接</a></p><ul><li>注意在&lt;script lang=”ts”&gt;中需要有lang=”ts”</li><li><strong>官方demo中引入的Vue，component是从每个不同的文件中引入的，其实可以从vue自带的’vue-property-decorator’中引入，<code>import { Component, Prop, Vue, Watch, ... } from &#39;vue-property-decorator&#39;;</code></strong></li></ul><p>vue-property-decorator提供如下七个装饰器和一个Mixins混合以及Vue类(来自<a href="https://github.com/kaorun343/vue-property-decorator#Model" target="_blank" rel="noopener">官方GitHub</a>)</p><ul><li><a href="#父子相传">@Prop</a></li><li><a href="#PropSync">@PropSync</a></li><li><a href="#父子v-model">@Model</a></li><li><a href="#watch">@Watch</a></li><li>@Provide</li><li>@Inject</li><li>@ProvideReactive</li><li>@InjectReactive</li><li><a href="#子传父">@Emit</a></li><li><a href="#ref/refs">@Ref</a></li><li><a href="#基础结构">@Component</a> <em>由<a href="https://github.com/vuejs/vue-class-component" target="_blank" rel="noopener">vue-class-component</a>组件提供</em></li><li><a href="#Mixin混入">Mixins</a> <em>the helper function named <code>mixins</code> defined at vue-class-component</em></li></ul><h2 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h2><p>typescript中的结构和普通vue中很相似，template中写dom、script写js、style写css，在script中采用了基于类的vue组件（毕竟是vue文件，用一般的写法也可以支持）</p><pre><code class="typescript">&lt;template&gt;    &lt;div class=&quot;hello&quot;&gt;        &lt;h1&gt;{{ msg }}&lt;/h1&gt;        &lt;h2&gt;{{ val }}&lt;/h2&gt;        &lt;button @click=&quot;change&quot;&gt;&lt;/button&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import { Component, Prop, Vue, Watch } from &#39;vue-property-decorator&#39;;@Componentexport default class HelloWorld extends Vue {    //data，methods，watch，computed的属性和函数都可以使用 private public readonly 来创建}&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt;&lt;/style&gt;</code></pre><h2 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h2><h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><p>typescript和vue中，创建一个数据并不需要放在data中，只需要</p><pre><code class="typescript">...export default class HelloWorld extends Vue {    val: string = &#39;我是被创建的数据&#39;    val2: number = 999    ...}...</code></pre><h3 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h3><p>方法直接创建在类中</p><pre><code class="typescript">...export default class HelloWorld extends Vue {    val: string = &#39;我是被创建的数据&#39;    change () {        return xxx    }    getVal () {        return this.val    }    ...}...</code></pre><h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><p>函数前边加get即可</p><pre><code class="typescript">...export default class HelloWorld extends Vue {    get computedData () { // 也可以写成 public get computedData        return xxx    }    ...}...</code></pre><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p>watch监听需要额外引入<code>import { Watch } from &#39;vue-property-decorator&#39;</code>，在<code>@Watch</code>的括号<code>()</code>中，写入要监听的属性名，如果需要给watch添加deep等属性，则需要<code>@Watch(&#39;val&#39;,{deep: true})</code></p><pre><code class="typescript">import { Component, Prop, Vue, Watch } from &#39;vue-property-decorator&#39;;...export default class HelloWorld extends Vue {    val: string = &#39;我是val&#39;    @Watch(&#39;val&#39;)    changeVal(data: any) {        console.log(data) // 我是val    }    ...}...</code></pre><h3 id="引入组件"><a href="#引入组件" class="headerlink" title="引入组件"></a>引入组件</h3><p>引入组件的位置需要在类上的@Component装饰器中引入（vuex中的内容也是在这里）</p><pre><code class="typescript">import HelloWorld from &#39;./HelloWorld.vue&#39;@Component({    components: { // 引入需要在这里引入        HelloWorld    },})export default class HelloWorld extends Vue {    ...}...</code></pre><h3 id="ref-refs"><a href="#ref-refs" class="headerlink" title="ref/refs"></a>ref/refs</h3><p>typescript中，$refs中的内容需要注册后使用</p><p>有两种方式注册，一种写成属性，一种是声明</p><pre><code class="typescript">&lt;template&gt;    &lt;hello-world ref=&quot;hw&quot; /&gt;&lt;/template&gt;import HelloWorld from &#39;./HelloWorld.vue&#39;@Component({    components: {        HelloWorld    },})export default class HelloWorld extends Vue {    $refs!: {               // 如果不注册，下面的hw.xxx会报错（hw取得是dom）        hw: HelloWorld      // 或者hw: HTMLFormElement    }    // @Ref() hw!: HelloWorld  第二种注册方式    change() {        console.log(this.$refs.hw.xxx)    }    ...}...</code></pre><h3 id="父子相传"><a href="#父子相传" class="headerlink" title="父子相传"></a>父子相传</h3><h4 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h4><p>父传子取值注册的时候和vue有所不同</p><p>有两种不同的注册方式</p><ol><li><p>官方demo中的prop注册方式,创建一个Vue.extend，在其中的props中接收传的值，然后再创建class类时继承创建的那个对象（AppProps）</p><pre><code class="typescript">const AppProps = Vue.extend({ props: {     propMessage: String }})export default class App extends AppProps { ...}</code></pre></li><li><p>正常创建class，继承Vue，在里边@props来接传过来的属性(推荐，比较方便)</p><pre><code class="typescript">import { Component, Prop, Vue } from &#39;vue-property-decorator&#39;@Componentexport default class HelloWorld extends Vue { @Prop() msg!: string @Prop() private names!: string}</code></pre></li></ol><h4 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h4><p>子传父时需要使用@Emit来传</p><pre><code class="typescript">// 父组件&lt;template&gt;...&lt;About @emitVal=&quot;propMsg&quot;/&gt;&lt;/template&gt;...// 子组件&lt;template&gt;    ...    &lt;button @click=&quot;propMsg&quot;&gt;点击给父组件发送数据&lt;/button&gt;    ...&lt;/template&gt;&lt;script lang=&quot;ts&quot; type=&quot;text/tsx&quot;&gt;    import { Component, Emit, Vue } from &quot;vue-property-decorator&quot;;    @Component    export default class About extends Vue {        @Emit(&quot;emitVal&quot;) send(data: string) {} // data为要传输的形参(send为属性名，可以任意更改的)        ...        propMsg() {            this.send(&#39;要传输的数据&#39;);        }    }&lt;/script&gt;</code></pre><h3 id="Mixin混入"><a href="#Mixin混入" class="headerlink" title="Mixin混入"></a>Mixin混入</h3><p><a href="https://github.com/vuejs/vue-class-component" target="_blank" rel="noopener">官方demo</a></p><p>mixin引入的文件为ts文件，可以通过<code>import { mixins } from &#39;vue-class-component&#39;</code>引入mixins，也可以通过<code>import { Mixins } from &#39;vue-property-decorator&#39;;</code>引入</p><pre><code class="typescript">// mixin.tsimport { Vue, Component } from &#39;vue-property-decorator&#39;@Componentexport default class helloMixin extends Vue {  mixinValue = &#39;Hello&#39;}// xxx.vue...import { Component, Vue, Mixins } from &#39;vue-property-decorator&#39;;import MyMixin from &quot;@/mixins/mixin.ts&quot;@Component()export default class HelloWorld extends Mixins(MyMixin) {    created() {        console.log(this.mixinValue)    }}...</code></pre><h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><p>可以通过<code>this.$store.state</code>等正常使用，如果想通过mapGetter等方式使用，需要引入 <code>vuex-class</code></p><pre><code>npm install --save vuex-class</code></pre><p>引入<code>vuex-class</code>，然后再class中@注册一下，就可以直接使用了</p><pre><code class="typescript">import {    State,    Mutation} from &#39;vuex-class&#39;@Component()export default class HelloWorld extends Vue {    @State storeVal:any    @Mutation setStoreVal:any    public change () {        console.log(this.storeVal)        this.setStoreVal(&#39;要传输的值&#39;)    }}// store中的内容...export default new Vuex.Store({    state: {        storeVal: &#39;store中的内容&#39;    },    mutations: {        setStoreVal(state: any, val: string) {            state.storeVal = val        }    }    ...})</code></pre><h3 id="父子v-model"><a href="#父子v-model" class="headerlink" title="父子v-model"></a>父子v-model</h3><p>v-model在typescript中在用法上截取model时有些区别，需要调用@Model来接取</p><pre><code class="typescript">// 父组件...&lt;content-dom v-model=&quot;val&quot; /&gt;...// 子组件...import { Component, Model, Vue, Emit } from &#39;vue-property-decorator&#39;;@Componentexport default class contentDom extends Vue {    @Model(&#39;change&#39;, { type: [Number,String] }) readonly value!:[Number,String]    // 在子组件中，付级传下来的只读参数映射为value，允许为Number或String组件（这里的Number为vue中的prop写法，首字母需大写），通过emit change向父级改变值    @Emit(&#39;change&#39;) sendValue(data: string|number) {}    public setValue() {        this.sendValue(&#39;值值值&#39;);        // this.$emit(&#39;change&#39;,&#39;值值值&#39;)   这种写法同样生效    }}</code></pre><h3 id="PropSync"><a href="#PropSync" class="headerlink" title="PropSync"></a>PropSync</h3><p>和父子级的v-model用处和用法都基本相同</p><pre><code class="typescript">// 父组件...&lt;content-dom :value.sync=&quot;val&quot; /&gt;...// 子组件...import { Component, PropSync, Vue } from &#39;vue-property-decorator&#39;;@Componentexport default class contentDom extends Vue {    @PropSync(&#39;value&#39;, { type: [Number,String] }) syncValue!: string|number    // 在子组件中，付级传下来的只读参数映射为syncValue，通过 update:value 向父级改变值    public setValue() {        this.$emit(&#39;update:value&#39;, &#39;值值值&#39;)    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typescript文档整理</title>
      <link href="/2019-12-11-7.html"/>
      <url>/2019-12-11-7.html</url>
      
        <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>安装<br><code>npm install -g typescript</code></p><p>转换<br><code>cmd  --&gt;  tsc xxx.ts                    //转换为js</code></p><h1 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h1><h2 id="原始数据类型"><a href="#原始数据类型" class="headerlink" title="原始数据类型"></a>原始数据类型</h2><pre><code class="typescript">let xxx: boolean = falselet xxx: number = 11let xxx: string = &#39;xxx&#39;let xxx: undefined = undefinedlet xxx: null  = nulllet xxx: any  = &#39;xxx&#39;</code></pre><p>原始数据类型包括：boolean、number、string、null、undefined 以及 Symbol(还有any)</p><blockquote><p><strong>类型推论：</strong> 如果没有声明类型，typescript会推测一个类型<br>如果定义时没有类型也没有赋值，都会被类型推论成any(任何)</p></blockquote><h3 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h3><p>void为空值，如果函数没有返回值的话，可以写void</p><pre><code class="typescript">function alertName(): void {    alert(&#39;&#39;);}</code></pre><p><em>如果定义一个空值，只能赋值为null或undefined</em></p><h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><pre><code class="typescript">let xxx:string|number = xxx</code></pre><p>可以设置xxx的类型为几种类型都可以<br>如果函数的形参为联合类型，则在函数中对形参的操作必须是联合类型中共有的方法，否则会报错  </p><p>报错：</p><pre><code class="typescript">function fun(data:string|number) :any {    return data.length}==&gt;error: 类型“string | number”上不存在属性“length”</code></pre><h2 id="接口（Interfaces）"><a href="#接口（Interfaces）" class="headerlink" title="接口（Interfaces）"></a>接口（Interfaces）</h2><h3 id="表示对象"><a href="#表示对象" class="headerlink" title="表示对象"></a>表示对象</h3><p>interface接口，可以预设一个类型<br>接口一般首字母大写</p><p>基础用法：</p><pre><code class="typescript">interface Person {    name: string;    age: number;}let tom: Person = {    name: &#39;Tom&#39;,    age: 25};</code></pre><ul><li>可选属性： 可以设置object中的某些函数不一定存在</li><li>任意属性： 可以添加任意多个符合条件的属性<br>如果可选属性和任意属性同时存在，任意属性的条件必须包括可选属性（如果同时存在，可选属性本身也就没有什么意义了）</li><li>只读属性： 必须在创建时赋值，赋值后不能修改，否则会报错（创建方法： readonly xxx: any）</li></ul><pre><code class="typescript">interface Person {    name: string;    age?: number; // 可选属性    [propName: string]: string|number; // 任意属性，条件是string|number    readonly id: number; // 只读属性}</code></pre><p>也可以现做现用</p><pre><code class="typescript">let data = {    a: 1,    b: 2,    c: &#39;33&#39;}let data2: {    a: number;    b: number;    c: string|number;} = data</code></pre><p><em>interface中分隔符为“;”，对象为“,”</em></p><h3 id="表示数组"><a href="#表示数组" class="headerlink" title="表示数组"></a>表示数组</h3><p>typescript创建数组的方式在下边<br>虽然接口也可以用来描述数组，但是一般不会这么写，因为这种方式复杂<br><em>数组内元素的数据类型一般情况下都是相同的(any[]类型除外)，如果想要不同的，可以使用<a href="#yuanZu">元组</a></em></p><pre><code class="typescript">interface NumberArray {    [index: number]: number;}let fibonacci: NumberArray = [1, 1, 2, 3, 5];</code></pre><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ol><li>「类型 + 方括号」表示法</li></ol><pre><code class="typescript">let xxx: number[] = [1, 1, 2, 3, 5];    // 数组中只能输入数字类型let xxx: any[] = [&#39;block xun&#39;, 18, { data: 1 }];      // 任意类型数组</code></pre><ol start="2"><li>数组泛型表示法</li></ol><p><strong>泛型是指 在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</strong></p><pre><code class="typescript">function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; {    let result: T[] = [];    for (let i = 0; i &lt; length; i++) {        result[i] = value;    }    return result;}let xxx: Array&lt;number&gt; = createArray&lt;number&gt;(5,4)===&gt;xxx = [4,4,4,4,4]</code></pre><p><T>在此处为泛型表示，在调用时可以指定“T”为具体的类型，如上个例子，将T指定成了number  </p><p>定义泛型时，可以一次性定义多个类型参数</p><pre><code class="typescript">function swap&lt;T, U&gt;(tuple: [T, U]): [U, T] {    return [tuple[1], tuple[0]];}swap([7, &#39;seven&#39;]); // [&#39;seven&#39;, 7]</code></pre><ol start="3"><li>接口形式表示</li></ol><p>不推荐使用接口形式表达，因为复杂</p><pre><code class="typescript">interface NumberArray {    [index: number]: number;}let fibonacci: NumberArray = [1, 1, 2, 3, 5];</code></pre><h2 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h2><p><em>我将类数组单独分出一个模块来记录，因为类数组的定义方式和数组区别很大,单独拿出来更容易理解</em></p><p>类数组不是数组类型，定义时应该使用接口  </p><p>arguments例子：</p><pre><code class="typescript">function sum() {    let args: {        [index: number]: number;        length: number;        callee: Function;    } = arguments;}</code></pre><p>或者使用内置的已经定义好的接口   IArguments</p><pre><code class="typescript">function sum() {    let args: IArguments = arguments;}</code></pre><p><em>IArguments时typescript中定义好的内置对象，他实际上就是上边例子中创建的接口</em><br><a href="https://ts.xcatliu.com/basics/built-in-objects" target="_blank" rel="noopener">更多内置对象，官网链接https://ts.xcatliu.com/basics/built-in-objects</a></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>常见的有两种定义方式，函数声明和函数表达式（和js一样）<br>执行时函数输入的形参，必须和创建时写的形参数量相一致</p><pre><code class="typescript">// 函数声明    function sum(x: number, y: number): number {    return x + y;}// 表达式    let mySum = function (x: number, y: number): number {    return x + y;};</code></pre><p>在表达式方法中</p><pre><code class="typescript">let mySum = function (x: number, y: number): number {    return x + y;};</code></pre><p>上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 mySum，是通过赋值操作进行类型推论而推断出来的。如果需要我们手动给 mySum 添加类型，则应该是这样：</p><pre><code class="typescript">let mySum: (x: number, y: number) =&gt; number = function (x: number, y: number): number {    return x + y;};</code></pre><p><strong>注意：</strong>=&gt;不是箭头函数，而是设定函数返回值为number，和上边的:number相同<br><em>个人理解为，一般情况下，=&gt;在=左边代表设定返回值，在=右边代表箭头函数</em></p><h4 id="用接口定义函数"><a href="#用接口定义函数" class="headerlink" title="用接口定义函数"></a>用接口定义函数</h4><pre><code class="typescript">interface SearchFunc {    (source: string, subString: string): boolean;}let mySearch: SearchFunc = function(source: string, subString: string) {    return source.search(subString) !== -1;}</code></pre><h4 id="可选参数设置"><a href="#可选参数设置" class="headerlink" title="可选参数设置"></a>可选参数设置</h4><p>?为可选参数，可选参数必须放在最后</p><pre><code class="typescript">function fun (data1:string,data2?:string) {    return &quot;xxx&quot;}</code></pre><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><pre><code class="typescript">function fun (data:string = &#39;xxx&#39;) {}</code></pre><h4 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h4><p>在创建参数时，可以设置剩余参数，当执行时输入的非定义的参数都会进入剩余参数这个数组中</p><pre><code class="typescript">function fun(data:string, ...data2:any[]) {}fun(&#39;data&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;)// data = &#39;data&#39;// data2 = [&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;]</code></pre><p><em>剩余参数为一个数组，数组中包括所有非形参的值</em></p><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>重载允许一个函数在接受不同参数的情况下做出不同的处理</p><pre><code class="typescript">// 要求：在输入string时输出string，在输入number时输出numberfunction fun (data:number):number;function fun (data:string):string;function fun (data:number | string):number | string {    ...    return data}</code></pre><p><em>前二次是函数定义，最后一次是函数实现，如果函数定义有包含关系，需要优先把精确的定义写在前边</em></p><p><em>在文章底部有详细的重载和合并的解释</em></p><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>两种写法</p><pre><code>&lt;类型&gt;值</code></pre><p>或</p><pre><code>值 as 类型</code></pre><p><em>在 tsx 语法（React 的 jsx 语法的 ts 版）中必须用后一种</em></p><p>在某种情况下，我们需要在还不确定类型的时候访问其中一个类型的属性或方法</p><pre><code class="typescript">function fun (data : string | number) {    if ((&lt;string&gt; data).length) {     // 这时需要加()将断言括起来        return (&lt;string&gt; data).length    } else {        return data    }}</code></pre><p><em>断言并不会改变类型，只会让之后的代码在typescript中不报错</em></p><h4 id="其他断言"><a href="#其他断言" class="headerlink" title="其他断言"></a>其他断言</h4><ul><li>非空(<code>null</code>或者<code>undefined</code>)断言 <code>!</code><br>例：<pre><code class="ts">@Prop() val! : string;</code></pre></li></ul><h4 id="断言-和-泛型-的区别"><a href="#断言-和-泛型-的区别" class="headerlink" title="断言 和 泛型 的区别"></a>断言 和 泛型 的区别</h4><p>断言：</p><pre><code>&lt;类型&gt;值值 as 类型</code></pre><p>泛型：<br>值&lt;类型&gt;</p><h2 id="声明语句和声明文件"><a href="#声明语句和声明文件" class="headerlink" title="声明语句和声明文件"></a>声明语句和声明文件</h2><p>在HTML中引入jQuery后，ts并不知道<code>$</code>或<code>jQuery</code>是什么，所以需要声明一下</p><pre><code class="typescript">declare var jQuery: (selector: string) =&gt; any;</code></pre><p>推荐使用第三方声明文件库 @types<br>第三方库中的文件不需要自己声明，已经声明好的<br>如types中的jQuery库 <code>npm install @types/jquery --save-dev</code><br><a href="https://microsoft.github.io/TypeSearch/" target="_blank" rel="noopener">可以在这个页面搜索你需要的声明文件</a></p><p>当一个第三方库没有提供声明文件时，我们就需要自己书写声明文件了</p><p>在不同的场景下，声明文件的内容和使用方式会有所区别。</p><p>库的使用场景主要有以下几种：</p><ul><li>全局变量：通过 &lt;script&gt; 标签引入第三方库，注入全局变量</li><li>npm 包：通过 import foo from ‘foo’ 导入，符合 ES6 模块规范</li><li>UMD 库：既可以通过 &lt;script&gt; 标签引入，又可以通过 import 导入</li><li>直接扩展全局变量：通过 &lt;script&gt; 标签引入后，改变一个全局变量的结构</li><li>在 npm 包或 UMD 库中扩展全局变量：引用 npm 包或 UMD 库后，改变一个全局变量的结构</li><li>模块插件：通过 &lt;script&gt; 或 import 导入后，改变另一个模块的结构</li></ul><blockquote><p>我们通常会把声明语句放到一个单独的声明文件中<br>声明文件必须以.d.ts结尾</p><pre><code class="typescript">// src/index.d.tsdeclare var jQuery: (selector: string) =&gt; any;</code></pre></blockquote><h3 id="1-declare-var"><a href="#1-declare-var" class="headerlink" title="1. declare var"></a>1. <code>declare var</code></h3><p>声明全局变量</p><p>在HTML中引入jQuery后，ts并不知道<code>$</code>或<code>jQuery</code>是什么，所以需要声明一下</p><pre><code class="typescript">declare var jQuery: (selector: string) =&gt; any;  // 相当于函数表达式方式定义jQuery， any代表返回值为任何值// 声明后才可使用jQuery(&#39;#div&#39;)</code></pre><p>declare出来的东西并没有真正定义变量，只是用于编译时检查，上边代码块编译后相当于js中的</p><pre><code class="typescript">jQuery(&#39;#div&#39;)</code></pre><p>还有 <code>declare let</code> 和 <code>declare const</code>,<code>let</code>和<code>var</code>没有什么区别<br><em>声明语句中只能定义类型，不能在declare后写具体的函数</em></p><h3 id="2-declare-function"><a href="#2-declare-function" class="headerlink" title="2. declare function"></a>2. <code>declare function</code></h3><p>declare function 用来定义全局函数的类型。jQuery 其实就是一个函数，所以也可以用 function 来定义（函数声明方式定义jQuery）</p><pre><code class="typescript">declare function jQuery(xxx:string): any// 执行jQuery(&#39;#foo&#39;);</code></pre><p>声明语句中支持函数重载</p><pre><code class="typescript">declare function jQuery(selector: string): any;declare function jQuery(domReadyCallback: () =&gt; any): any;</code></pre><h3 id="3-declare-class类"><a href="#3-declare-class类" class="headerlink" title="3. declare class类"></a>3. <code>declare class</code>类</h3><p>定义一个全局类</p><pre><code class="typescript">declare class Animal {    name: string;    constructor(name: string);    sayHi(): string;}// 执行let cat = new Animal(&#39;Tom&#39;);</code></pre><h3 id="4-declare-enum外部枚举"><a href="#4-declare-enum外部枚举" class="headerlink" title="4. declare enum外部枚举"></a>4. <code>declare enum</code>外部枚举</h3><p>定义外部枚举<br>declare enum xxx {<br>    a,<br>    b,<br>    c<br>}<br>使用：xxx.a</p><h3 id="5-interface-和-type"><a href="#5-interface-和-type" class="headerlink" title="5. interface 和 type"></a>5. <code>interface</code> 和 <code>type</code></h3><p>除了全局变量之外，可能有一些类型我们也希望能暴露出来。在类型声明文件中，我们可以直接使用 interface 或 type 来声明一个全局的接口或类型</p><pre><code class="typescript">// src/jQuery.d.tsinterface AjaxSettings {    method?: &#39;GET&#39; | &#39;POST&#39;    data?: any;}declare namespace jQuery {    function ajax(url: string, settings?: AjaxSettings): void;}</code></pre><p>这样的话，在其他文件中也可以使用这个接口或类型了：</p><pre><code class="typescript">// src/index.tslet settings: AjaxSettings = {    method: &#39;POST&#39;,    data: {        name: &#39;foo&#39;    }};jQuery.ajax(&#39;/api/post_something&#39;, settings);</code></pre><h2 id="export-导入"><a href="#export-导入" class="headerlink" title="export 导入"></a>export 导入</h2><p>待完善<br>export const name: string;<br>export function getName(): string;<br>export interface data {<br>data1: any<br>}<br>import { xxx } from ‘xxx’</p><p>export default<br>同上（导出值为对象之前，要先declare enum定义出来）<br>ts推荐导入方法<br>import data = requirt(‘xxx’)  // 整体导入<br>import bar = data.a  // 单个导入</p><p>二部分<br>类型别名<br>type创建类型别名<br>type data = string;<br>function () {}</p><h1 id="进阶部分"><a href="#进阶部分" class="headerlink" title="进阶部分"></a>进阶部分</h1><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p><code>type</code> 类型别名用来给一个类型或联合类型起一个新名字</p><pre><code class="typescript">type Name = string;type NameResolver = () =&gt; string;type NameOrResolver = Name | NameResolver;function getName(n: NameOrResolver): Name {    if (typeof n === &#39;string&#39;) {        return n;    } else {        return n();    }}</code></pre><p><strong>类型别名与字符串字面量类型都是使用 type 进行定义</strong></p><h2 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h2><p><code>type</code> 字符串字面量类型用来约束取值只能是某几个字符串中的一个。</p><pre><code class="typescript">type EventNames = &#39;click&#39; | &#39;scroll&#39; | &#39;mousemove&#39;;function handleEvent(ele: Element, event: EventNames) {    // do something}handleEvent(document.getElementById(&#39;hello&#39;), &#39;scroll&#39;);  // 没问题handleEvent(document.getElementById(&#39;world&#39;), &#39;dbclick&#39;); // 报错，event 不能为 &#39;dbclick&#39;</code></pre><p><em>因为上边定义了EventNames只能是’click’，’scroll’，’mousemove’之中的一个，所以第二次调用报错了</em></p><p><strong>类型别名与字符串字面量类型都是使用 type 进行定义</strong></p><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p><span id="yuanZu"></span></p><p>typescript数组中元素的数据类型一般都是相同的（any[]类型的数组可以不同），如果存储的元素数据类型不同，则需要使用元组</p><p>创建一个元组</p><pre><code class="typescript">var tuple = [10, &quot;data&quot;];// 或let tuple: [number, string] = [10, &quot;data&quot;];// 或let tuple: [number, string];tuple[0] = 10;tuple[1] = &quot;data&quot;;// 也可以只赋值一项let tuple: [number, string];tuple[0] = 10;</code></pre><p>当添加越界（过多）的元素时，他的类型会被限制为元组中所有写过的类型的联合类型</p><pre><code class="typescript">let tom: [string, number];tom = [&#39;Tom&#39;, 25];tom.push(&#39;male&#39;);  // 正常添加，不会报错tom.push(true);  // 这时会报错，因为这个元组中定义了只能添加string和number类型</code></pre><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>JavaScript中本身没有枚举类型，枚举能够给一系列数值集合提供友好的名称，也就是说枚举可以表示一个命名元素的集合。</p><pre><code class="typescript">enum Days {Sun, Mon, Tue, Wed, Thu, Fri, Sat};</code></pre><p>枚举成员会被赋值为从 0 开始递增的”索引”，同时”索引”也会反向赋值</p><pre><code class="typescript">enum Days {Sun, Mon, Tue, Wed, Thu, Fri, Sat};console.log(Days[&quot;Sun&quot;] === 0); // trueconsole.log(Days[&quot;Mon&quot;] === 1); // trueconsole.log(Days[&quot;Tue&quot;] === 2); // trueconsole.log(Days[&quot;Sat&quot;] === 6); // trueconsole.log(Days[0] === &quot;Sun&quot;); // trueconsole.log(Days[1] === &quot;Mon&quot;); // trueconsole.log(Days[2] === &quot;Tue&quot;); // trueconsole.log(Days[6] === &quot;Sat&quot;); // true</code></pre><p>上边的例子会被编译为：</p><pre><code class="typescript">var Days;(function (Days) {    Days[Days[&quot;Sun&quot;] = 0] = &quot;Sun&quot;;    Days[Days[&quot;Mon&quot;] = 1] = &quot;Mon&quot;;    Days[Days[&quot;Tue&quot;] = 2] = &quot;Tue&quot;;    Days[Days[&quot;Wed&quot;] = 3] = &quot;Wed&quot;;    Days[Days[&quot;Thu&quot;] = 4] = &quot;Thu&quot;;    Days[Days[&quot;Fri&quot;] = 5] = &quot;Fri&quot;;    Days[Days[&quot;Sat&quot;] = 6] = &quot;Sat&quot;;})(Days || (Days = {}));</code></pre><p>也可以手动赋值给枚举类型</p><pre><code class="typescript">enum Days {Sun = 7, why = &lt;any&gt;&quot;wow&quot;, Mon = 20, Tue = 18, Wed, Thu, Fri, Sat, fun = &lt;any&gt;(&quot;fun&quot; + &quot;fun&quot;), len = &quot;len&quot;.length};</code></pre><p>没有手动赋值的项会根据上一项的枚举值继续递增<br>如果手动赋值的值和自动递增的值重复了，typescript不会做出任何处理<br>手动赋值项可以不是数字类型，甚至可以使用表达式，但需要使用断言来无视类型检查<br>注意手动赋值如果不是数字类型，而且后边是一个自动生成值得参数，则会因为生成不了参数而报错</p><pre><code class="typescript">编译成js后...var Days;(function (Days) {    Days[Days[&quot;Sun&quot;] = 7] = &quot;Sun&quot;;    Days[Days[&quot;why&quot;] = &quot;wow&quot;] = &quot;why&quot;;    Days[Days[&quot;Mon&quot;] = 20] = &quot;Mon&quot;;    Days[Days[&quot;Tue&quot;] = 18] = &quot;Tue&quot;;    Days[Days[&quot;Wed&quot;] = 19] = &quot;Wed&quot;;    Days[Days[&quot;Thu&quot;] = 20] = &quot;Thu&quot;;    Days[Days[&quot;Fri&quot;] = 21] = &quot;Fri&quot;;    Days[Days[&quot;Sat&quot;] = 22] = &quot;Sat&quot;;    Days[Days[&quot;fun&quot;] = (&quot;fun&quot; + &quot;fun&quot;)] = &quot;fun&quot;;    Days[Days[&quot;len&quot;] = &quot;len&quot;.length] = &quot;len&quot;;})(Days || (Days = {}));</code></pre><h3 id="常数枚举"><a href="#常数枚举" class="headerlink" title="常数枚举"></a>常数枚举</h3><ul><li>常数枚举只能自动生成</li><li>常熟枚举会在编译阶段被删除</li></ul><pre><code class="typescript">const enum Days {Sun, Mon, Tue, Wed, Thu, Fri, Sat};</code></pre><blockquote><p><em><strong>外部枚举也会在编译阶段被删除</strong></em></p></blockquote><h2 id="class-类"><a href="#class-类" class="headerlink" title="class 类"></a>class 类</h2><p>和ES6中正常的class类的使用方法类似，不过有些地方有区别</p><p>TypeScript 可以使用三种访问修饰符（Access Modifiers），分别是 public、private 和 protected。  </p><ul><li><p>public 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的</p></li><li><p>private 修饰的属性或方法是私有的，不能在声明它的类的外部访问<br><em>只能在类内部访问，不能在实例（new）和继承（extend）中使用，如果构造函数（constructor）被设定为该类型，则该类不允许被继承或实例化</em></p></li><li><p>protected 修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的<br><em>能在类内部访问，也可以在继承（extend）中使用，不能在实例（new）中使用</em></p></li><li><p>readonly 只读属性关键字，只允许出现在属性声明或索引签名中。（如果和上三个之一同时使用的话，要把readonly写在那三个之后）</p></li></ul><p>示例：<br>public：</p><pre><code class="typescript">class Animal {    public name;    public constructor(name) {        this.name = name;    }}let a = new Animal(&#39;Jack&#39;);console.log(a.name); // Jacka.name = &#39;Tom&#39;;console.log(a.name); // Tom</code></pre><p>private：</p><pre><code class="typescript">class Animal {    private name;    public constructor(name) {        this.name = name;    }}class Cat extends Animal {  // 继承    constructor(name) {        super(name);        console.log(this.name); // 会报错    }}let a = new Animal(&#39;Jack&#39;); // 实例console.log(a.name); // 会报错</code></pre><p>protected：</p><pre><code class="typescript">class Animal {    public name;    protected constructor (name) {        this.name = name;  }}class Cat extends Animal {    constructor (name) {        super(name);    }}let a = new Animal(&#39;Jack&#39;); // 会报错</code></pre><p>如果想禁止继承和实例：</p><pre><code class="typescript">class Animal {    public name;    private constructor (name) { // 如果只想禁止实例，把private换成protected        this.name = name;  }}class Cat extends Animal { // 会报错    ...}let a = new Animal(&#39;Jack&#39;); // 会报错</code></pre><p>readonly</p><pre><code class="typescript">class Animal {    readonly name;    public constructor(name) {        this.name = name;    }}let a = new Animal(&#39;Jack&#39;);console.log(a.name); // Jacka.name = &#39;Tom&#39;;  // 报错</code></pre><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul><li>抽象类不允许被实例化</li><li>抽象类中的<strong>抽象方法</strong>必须在子类中实现（创建）</li></ul><pre><code class="typescript">abstract class Animal {    public name;    public constructor(name) {        this.name = name;    }    public abstract sayHi()}class Cat extends Animal {    public sayHi() { // 在此处创建了父类的抽象类sayHi        console.log(`Meow, My name is ${this.name}`);    }}let cat = new Cat(&#39;Tom&#39;);cat.sayHi()</code></pre><h3 id="类和接口"><a href="#类和接口" class="headerlink" title="类和接口"></a>类和接口</h3><p>在typescript中，可以用 <code>implements</code> 把接口提取成类的接口  </p><pre><code class="typescript">interface Alarm {    alert();}class Door {}class SecurityDoor extends Door implements Alarm {    alert() {        console.log(&#39;SecurityDoor alert&#39;);    }}class Car implements Alarm {    alert() {        console.log(&#39;Car alert&#39;);    }}</code></pre><p>一个类可以使用多个接口</p><pre><code class="typescript">interface Alarm {    alert();}interface Light {    lightOn();    lightOff();}class Car implements Alarm, Light {    alert() {        console.log(&#39;Car alert&#39;);    }    lightOn() {        console.log(&#39;Car light on&#39;);    }    lightOff() {        console.log(&#39;Car light off&#39;);    }}</code></pre><p>接口之间也可以相互继承</p><pre><code class="typescript">interface Alarm {    alert();}interface LightableAlarm extends Alarm {    lightOn();    lightOff();}</code></pre><p>接口继承类</p><pre><code class="typescript">class Point {    x: number;    y: number;}interface Point3d extends Point {    z: number;}let point3d: Point3d = {x: 1, y: 2, z: 3};</code></pre><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ul><li>泛型是指 在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性</li></ul><pre><code class="typescript">function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; {    let result: T[] = [];    for (let i = 0; i &lt; length; i++) {        result[i] = value;    }    return result;}let xxx: Array&lt;number&gt; = createArray&lt;number&gt;(5,4)===&gt;xxx = [4,4,4,4,4]</code></pre><p><T>在此处为泛型表示，在调用时可以指定“T”为具体的类型，如上个例子，将T指定成了number  </p><p>定义泛型时，可以一次性定义多个类型参数</p><pre><code class="typescript">function swap&lt;T, U&gt;(tuple: [T, U]): [U, T] {    return [tuple[1], tuple[0]];}swap([7, &#39;seven&#39;]); // [&#39;seven&#39;, 7]</code></pre><p><strong>泛型参数可以传入默认值</strong></p><pre><code class="typescript">function createArray&lt;T = number&gt;(length: number, value: T): Array&lt;T&gt; {    let result: T[] = [];    for (let i = 0; i &lt; length; i++) {        result[i] = value;    }    return result;}let xxx: Array&lt;number&gt; = createArray(5,4)</code></pre><h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p>在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法<br>如下方例子，泛型 <code>T</code>不一定包含属性<code>length</code>，所以编译的时候报错了</p><pre><code class="typescript">function loggingIdentity&lt;T&gt;(arg: T): T {    console.log(arg.length);    return arg;}// error: Property &#39;length&#39; does not exist on type &#39;T&#39;.</code></pre><p>使用extends进行泛型约束，如下例，只允许符合Lengthwise的的值(传入的值.length必须是number格式)</p><pre><code class="typescript">interface Lengthwise {    length: number;}function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T {    console.log(arg.length);    return arg;}</code></pre><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>泛型接口有两周表达的方式</p><ol><li><p>将泛型放在接口的内部</p><pre><code class="typescript">interface CreateArrayFunc { &lt;T&gt;(length: number, value: T): Array&lt;T&gt;;}let createArray: CreateArrayFunc; // 定义的泛型在调用时并没有传值createArray = function&lt;T&gt;(length: number, value: T): Array&lt;T&gt; { let result: T[] = []; for (let i = 0; i &lt; length; i++) {     result[i] = value; } return result;}createArray(3, &#39;x&#39;); // [&#39;x&#39;, &#39;x&#39;, &#39;x&#39;]</code></pre></li><li><p>将泛型提前到接口名上（更方便给泛型传值）</p></li></ol><pre><code class="typescript">interface CreateArrayFunc&lt;T&gt; {    (length: number, value: T): Array&lt;T&gt;;}let createArray: CreateArrayFunc&lt;any&gt;; // 给泛型传入any值（也可以不传值，象上一个代码块那样写）createArray = function&lt;T&gt;(length: number, value: T): Array&lt;T&gt; {    let result: T[] = [];    for (let i = 0; i &lt; length; i++) {        result[i] = value;    }    return result;}createArray(3, &#39;x&#39;); // [&#39;x&#39;, &#39;x&#39;, &#39;x&#39;]</code></pre><p><strong>如果不给接口中的泛型传值，泛型会被“定义”为“T”型（T可以使任何类型，但也不是任何类型，也就是说T类型 = T类型，其他类型 ！= T类型）</strong><br><em>比如：函数的一个形参为T类型，返回值为T类型，那么只有那个T类型的形参可以作为返回值</em></p><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>泛型类的使用方法和正常泛型接口类似</p><pre><code class="typescript">class GenericNumber&lt;T&gt; {    zeroValue: T;    add: (x: T, y: T) =&gt; T;}let myGenericNumber = new GenericNumber&lt;number&gt;();myGenericNumber.zeroValue = 0;myGenericNumber.add = function(x, y) { return x + y; };</code></pre><h2 id="重载与合并"><a href="#重载与合并" class="headerlink" title="重载与合并"></a>重载与合并</h2><h3 id="重载-1"><a href="#重载-1" class="headerlink" title="重载"></a>重载</h3><p>重复定义一个函数，函数会进行重载</p><p><em>重载允许一个函数在接受不同参数的情况下做出不同的处理</em></p><pre><code class="typescript">// 要求：在输入string时输出string，在输入number时输出numberfunction fun (data:number):number;function fun (data:string):string;function fun (data:number | string):number | string {    ...    return data}</code></pre><p><em>前二次是函数定义，最后一次是函数实现，如果函数定义有包含关系，需要优先把精确的定义写在前边</em></p><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>重复输入一个一个接口或者类，会实现函数合并</p><p>简单实现的例子</p><pre><code class="typescript">interface Alarm {    price: number;}interface Alarm {    weight: number;}// 合并成interface Alarm {    price: number;    weight: number;}</code></pre><p>如果合并的<strong>属性</strong>冲突，并且不一致，会报错</p><pre><code class="typescript">interface Alarm {    price: number;}interface Alarm {    price: string;  // 报错（如果这里是price: number;则不会报错）    weight: number;}</code></pre><p>如果合并的<strong>函数</strong>冲突，则与函数重载效果一致</p><pre><code class="typescript">interface Alarm {    price: number;    alert(s: string): string;}interface Alarm {    weight: number;    alert(s: string, n: number): string;}// 合并成interface Alarm {    price: number;    weight: number;    alert(s: string): string;    alert(s: string, n: number): string;}</code></pre><p>或</p><pre><code class="typescript">interface Alarm {    price: number;    alert(s: string): string;    alert(s: number): number;}interface Alarm {    weight: number;    alert(s: string, n: number): string;}// 合并成interface Alarm {    price: number;    weight: number;    alert(s: string): string;    alert(s: number): number;    alert(s: string, n: number): string;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 文档整理 </tag>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSON.string详解</title>
      <link href="/2019-12-10-6.html"/>
      <url>/2019-12-10-6.html</url>
      
        <content type="html"><![CDATA[<h2 id="JSON-string-的特性"><a href="#JSON-string-的特性" class="headerlink" title="JSON.string 的特性"></a>JSON.string 的特性</h2><h3 id="1-JSON-stringify对undefined、函数、symbol的转换"><a href="#1-JSON-stringify对undefined、函数、symbol的转换" class="headerlink" title="1.JSON.stringify对undefined、函数、symbol的转换"></a>1.JSON.stringify对undefined、函数、symbol的转换</h3><ol><li>undefined、函数、symbol单独转换时，会返回undefined  </li><li>undefined、函数、symbol作为对象的属性时，会跳过他们  </li><li>undefined、函数、symbol作为数组元素时，将被转换为null  </li></ol><pre><code>1.JSON.stringify(Symbol(&#39;x&#39;))JSON.stringify(undefined)JSON.stringify(function() { return true; })===&gt;undefined         // undefined不是字符串2.const data = {    a: &quot;a&quot;,    b: undefined,    c: Symbol(&quot;a&quot;),    fn: function() { return true; }};JSON.stringify(data)===&gt;&#39;{a:&quot;a&quot;}&#39;3.JSON.stringify([&quot;a&quot;, undefined, Symbol(&quot;a&quot;), function() { return true; }])===&gt;&#39;[&quot;a&quot;]&#39;</code></pre><p><em>Symbol: Symbol是ES6新增的基础类型，用typeof或…toString检查类型的话会返回’symbol’和’[object Symbol]’，他的每一个实例都是唯一的(很像一个不能添加属性的对象)，有<strong>proto</strong>属性</em></p><h3 id="2-JSON-stringify不能保证在执行参数为对象时执行后的字符串中对象的顺序"><a href="#2-JSON-stringify不能保证在执行参数为对象时执行后的字符串中对象的顺序" class="headerlink" title="2.JSON.stringify不能保证在执行参数为对象时执行后的字符串中对象的顺序"></a>2.JSON.stringify不能保证在执行参数为对象时执行后的字符串中对象的顺序</h3><p>因为序列化时会忽略一些特殊的值（如#1），所以不能保证序列化后的字符串还是以特定的顺序出现（数组除外）。</p><h3 id="3-JSON-stringify和toJSON函数"><a href="#3-JSON-stringify和toJSON函数" class="headerlink" title="3.JSON.stringify和toJSON函数"></a>3.JSON.stringify和toJSON函数</h3><p>如果JSON.stringify的参数如果是对象并且对象中有名为toJSON的函数，或数组的<strong>proto</strong>中有toJSON(数组[]中包括不行)，执行的结果则是toJSON函数返回的值</p><pre><code>JSON.stringify({    a: &quot;a&quot;,    toJSON: function() {        return &quot;b&quot;;    }})===&gt;&#39;b&#39;var a = [1,2,3,4]a.__proto__.toJSON = function () {}===&gt;undefined</code></pre><h3 id="4-JSON-stringify-将会正常序列化-Date-的值"><a href="#4-JSON-stringify-将会正常序列化-Date-的值" class="headerlink" title="4.JSON.stringify() 将会正常序列化 Date 的值"></a>4.JSON.stringify() 将会正常序列化 Date 的值</h3><p>JSON.stringify会正常序列化Date的值</p><pre><code>JSON.stringify({ a: new Date() });===&gt;&quot;{&quot;a&quot;:&quot;2019-12-10T06:59:58.001Z&quot;}&quot;</code></pre><p>实际上Date对象自己部署了toJSON()方法，因此会被当做字符串处理</p><pre><code>a.a.toJSON===&gt;ƒ toJSON() { [native code] }</code></pre><h3 id="5-NaN-和-Infinity-格式的数值及-null-都会被当做-null"><a href="#5-NaN-和-Infinity-格式的数值及-null-都会被当做-null" class="headerlink" title="5.NaN 和 Infinity 格式的数值及 null 都会被当做 null"></a>5.NaN 和 Infinity 格式的数值及 null 都会被当做 null</h3><pre><code>JSON.stringify(NaN)===&gt;&quot;null&quot;JSON.stringify(null)===&gt;&quot;null&quot;JSON.stringify(Infinity)===&gt;&quot;null&quot;</code></pre><h3 id="6-布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值"><a href="#6-布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值" class="headerlink" title="6.布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值"></a>6.布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值</h3><pre><code>JSON.stringify([new Number(1), new String(&quot;false&quot;), new Boolean(false)]);===&gt;&quot;[1,&quot;false&quot;,false]&quot;</code></pre><h3 id="7-Map-Set等只会转换可枚举的属性"><a href="#7-Map-Set等只会转换可枚举的属性" class="headerlink" title="7. Map/Set等只会转换可枚举的属性"></a>7. Map/Set等只会转换可枚举的属性</h3><pre><code>JSON.stringify(     Object.create(        null,         {             x: { value: &#39;json&#39;, enumerable: false },             y: { value: &#39;stringify&#39;, enumerable: true }         }    ));===&gt;&quot;{&quot;y&quot;:&quot;stringify&quot;}&quot;</code></pre><h3 id="8-循环引用会报错"><a href="#8-循环引用会报错" class="headerlink" title="8.循环引用会报错"></a>8.循环引用会报错</h3><p>对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误。 </p><pre><code>const obj = {  name: &quot;loopObj&quot;};const loopObj = {  obj};obj.loopObj = loopObj;===&gt;error...</code></pre><h3 id="9-symbol属性会被忽略"><a href="#9-symbol属性会被忽略" class="headerlink" title="9.symbol属性会被忽略"></a>9.symbol属性会被忽略</h3><p>所有以symbol为属性键的属性都会被完全忽略掉，即便replacer参数中强制指定包含了它们。</p><pre><code>JSON.stringify({ [Symbol.for(&quot;json&quot;)]: &quot;stringify&quot; }, function(k, v) {    if (typeof k === &quot;symbol&quot;) {        return v;    }})</code></pre><p>如果不清楚JSON.stringify的第二个参数的话往下看(JSON.string的第二个参数)</p><h2 id="JSON-string的第二个参数"><a href="#JSON-string的第二个参数" class="headerlink" title="JSON.string的第二个参数"></a>JSON.string的第二个参数</h2><p>JSON.string的第二个参数可以使数组，也可以是一个过滤函数</p><h3 id="参数为数组时"><a href="#参数为数组时" class="headerlink" title="参数为数组时"></a>参数为数组时</h3><p>参数为数组时，相当于是前一个属性的白名单，对前边的对象进行过滤，只有对象中属性名在数组中的属性才会被执行，否则跳过</p><pre><code>JSON.stringify({ a:1, b:2, c:3 }, [&#39;a&#39;, &#39;b&#39;])===&gt;&quot;{&quot;a&quot;:1,&quot;b&quot;:2}&quot;</code></pre><h3 id="参数为函数时"><a href="#参数为函数时" class="headerlink" title="参数为函数时"></a>参数为函数时</h3><p>参数为函数时，函数有两个形参 key, value<br>可以使用函数来控制输出之前那些被忽略的属性</p><p><strong>最一开始key会接收到空值，value为要序列化的对象，第一轮必须返回这个对象（value），否者JSON.string的返回值会为””””，因为下一轮执行内部需要用到之前的key，value</strong><br><em>确保第一轮返回value的方法，最稳妥的就是在函数尾部协商return value，然后在前边做if判断拦截需要修改的数据</em></p><pre><code>var a = { a:1, b:2, c:3, d: Symbol(4) }JSON.stringify(a, function (key, value) {    console.log(&quot;key  &quot; , key)    console.log(&quot;value  &quot; , value)    if (typeof value === &quot;symbol&quot;) {        return value.toString()    }    return value})===&gt;key           // 第一个key为空value   {a: 1, b: 2, c: 3, d: Symbol(4)}       // 第一个value为整个数组（value === a ===&gt; true）key   avalue   1key   bvalue   2key   cvalue   3key   dvalue   Symbol(4)&quot;{&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3,&quot;d&quot;:&quot;Symbol(4)&quot;}&quot;    // 这个是返回值</code></pre><h2 id="JSON-string的第三个参数"><a href="#JSON-string的第三个参数" class="headerlink" title="JSON.string的第三个参数"></a>JSON.string的第三个参数</h2><p>用于在数组或者对象转换前在每个属性/索引前增加内容<br>参数可以使数字或字符串</p><ul><li>如果是一个数字, 则在字符串化时每一级别会比上一级别缩进多这个数字值的空格（最多10个）</li><li>如果是一个字符串，则会添加在属性名前边（每一级别会比上一级别多缩进该字符串）</li></ul><p>对象举例：</p><pre><code>var a = {    a: &quot;1&quot;,    b: &quot;2&quot;,    c: &quot;3&quot;,    d: {        e: &quot;4&quot;    }}// 参数为字符串JSON.stringify(a,null,&#39;aa&#39;)===&gt;&quot;{aa&quot;a&quot;: &quot;1&quot;,aa&quot;b&quot;: &quot;2&quot;,aa&quot;c&quot;: &quot;3&quot;,aa&quot;d&quot;: {aaaa&quot;e&quot;: &quot;4&quot;aa}}&quot;// 参数为数字JSON.stringify(a,null,5)===&gt;&quot;{     &quot;a&quot;: &quot;1&quot;,     &quot;b&quot;: &quot;2&quot;,     &quot;c&quot;: &quot;3&quot;,     &quot;d&quot;: {          &quot;e&quot;: &quot;4&quot;     }         // 每行前空5格，e空10格}&quot;</code></pre><p>数组举例：</p><pre><code>var a = [1,2,3,4,{a:1,b:2}]// 参数为字符串JSON.stringify(a,null,&#39;aa&#39;)===&gt;&quot;[aa1,aa2,aa3,aa4,aa{aaaa&quot;a&quot;: 1,aaaa&quot;b&quot;: 2aa}]&quot;// 参数为数字JSON.stringify(a,null,5)===&gt;&quot;[     1,     2,     3,     4,     {          &quot;a&quot;: 1,          &quot;b&quot;: 2     }]&quot;        // 每行前空5格，a,b空10格</code></pre><p><a href="https://juejin.im/post/5decf09de51d45584d238319" target="_blank" rel="noopener">参考链接 掘金 弹铁蛋同学</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谷歌浏览器插件开发</title>
      <link href="/2019-12-06-5.html"/>
      <url>/2019-12-06-5.html</url>
      
        <content type="html"><![CDATA[<h1 id="谷歌浏览器插件开发"><a href="#谷歌浏览器插件开发" class="headerlink" title="谷歌浏览器插件开发"></a>谷歌浏览器插件开发</h1><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>首先， manifest.json 文件为必须，他是json格式的配置文件  </p><p>个人理想的基础目录结构：</p><pre><code>|-- css // 用于存放css文件|--  -- xx.css|-- image // 用于存放图片文件|--  -- xx.png|-- js // 用于存放js文件|--  -- xx.js|-- popup.html // 首页（非必要）|-- icon.png // icon标志文件|-- manifest.json // json配置文件</code></pre><h2 id="manifest-json配置文件"><a href="#manifest-json配置文件" class="headerlink" title="manifest.json配置文件"></a>manifest.json配置文件</h2><h3 id="必填字段"><a href="#必填字段" class="headerlink" title="必填字段"></a>必填字段</h3><pre><code>&quot;name&quot;: &quot;名字&quot; // 名称&quot;version&quot;: &quot;1.0.0&quot; // 版本号&quot;manifest_version&quot;: 2 // 清单文件的版本，这个必须写，而且必须是2</code></pre><h3 id="插件相关介绍"><a href="#插件相关介绍" class="headerlink" title="插件相关介绍"></a>插件相关介绍</h3><pre><code>&quot;description&quot;: &quot;简介&quot; // 插件介绍&quot;author&quot;: &quot;blockXun&quot;, // 作者&quot;default_locale&quot;: &quot;en&quot; // 国际化（一般情况下没必要可以不写）</code></pre><h3 id="标志，插件主页设置"><a href="#标志，插件主页设置" class="headerlink" title="标志，插件主页设置"></a>标志，插件主页设置</h3><p>icons字段代表着在设置——扩展程序页面中看到的图标，在没有写browser_action字段的情况下，icons的图标也是浏览器右上角插件的图标<br>插件主页指的是点击浏览器右上角的插件后弹出的页面，通过browser_action的default_popup设置路径，如果不设置default_popup的话，点击插件则默认不会弹出任何东西</p><pre><code>&quot;icons&quot;: {    &quot;16&quot;: &quot;icon.png&quot;,    &quot;48&quot;: &quot;icon.png&quot;,    &quot;128&quot;: &quot;icon.png&quot;,} // 插件图标,分为不同的尺寸，允许只写一种，也允许三种尺寸选择一个图标&quot;browser_action&quot;: { // 浏览器右上角的图标    &quot;default_icon&quot;: &quot;icon.png&quot; // 图标路径（推荐19px的，大图会被缩放）    &quot;default_title&quot;: &quot;名字&quot; // 鼠标触碰图标时显示的名称    &quot;default_popup&quot;: &quot;popup.html&quot; // 可选，点击时弹出的页面（如果不写点击时则不会弹出页面）}</code></pre><p>也可以使用chrome.browserAction.setTitle()方法来改变鼠标触碰图标时的名字  </p><p>在标志上显示文本信息<br>由于空间限制，只支持4个字符一下的文字（中文2，英文4），也可以设置颜色<br>在background中写能够执行</p><pre><code>chrome.browserAction.setBadgeText({text: &#39;new&#39;}); // 文字chrome.browserAction.setBadgeTextColor({color: [255, 0, 255, 255]}); // 文字颜色（目前只有火狐支持）chrome.browserAction.setBadgeBackgroundColor({color: [255, 0, 0, 255]}); // 文字背景颜色</code></pre><h3 id="background-后台"><a href="#background-后台" class="headerlink" title="background 后台"></a>background 后台</h3><p>它的生命周期是插件中所有类型页面中最长的，它随着浏览器打开和关闭，所以通常把需要一直运行的和启动就运行的代码放在background里面。<br>如果加上persistent = false 的话，background会在被需要时加载，空闲时关闭</p><pre><code>&quot;background&quot;: // 后台，随着浏览器打开和关闭    { // 两种写法，一种是&quot;page&quot;，指定一个html页面，一种是&quot;scripts&quot;直接指定js，Chrome会自动生成一个默认的网页        &quot;page&quot;: &quot;background.html&quot;, // 两种只需写一个        &quot;scripts&quot;: [&quot;js/background.js&quot;], // 两种只需写一个        &quot;persistent&quot;: false // 如果加上这句话，background会在被需要时加载，空闲时关闭    },</code></pre><h3 id="向页面注入脚本"><a href="#向页面注入脚本" class="headerlink" title="向页面注入脚本"></a>向页面注入脚本</h3><pre><code>&quot;content_scripts&quot;: [ // 是个数组    {        &quot;matches&quot;: [&quot;&lt;all_urls&gt;&quot;], // 需要执行注入的url，如：&quot;https://*/*&quot;，&lt;all_urls&gt;为所有页面都注入        &quot;js&quot;: [], // 注入的js文件        &quot;css&quot;: [], // 注入的css文件        &quot;run_at&quot;: &quot;document_start&quot; // 注入代码的执行时间（可选值在下方）    }]</code></pre><blockquote><p>run_at可选的值<br>document_start CSS加载完毕，没有加载DOM时<br>document_end  DOM创建完成还没有加载图片等资源时<br>document_idle 默认值，译为空闲时 具体执行时间是在document_end和window.onload之间</p></blockquote><h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><p>权限请求，一些功能需要设置权限才可以使用</p><pre><code>&quot;permissions&quot;: [    &quot;contextMenus&quot;, // 右键菜单    &quot;tabs&quot;, // 标签    &quot;notifications&quot;, // 通知    &quot;webRequest&quot;, // web请求    &quot;webRequestBlocking&quot;, // 阻塞式web请求    &quot;storage&quot;, // 插件本地存储    &quot;http://*/*&quot;, // 可以通过executeScript或者insertCSS访问的网站    &quot;https://*/*&quot; // 可以通过executeScript或者insertCSS访问的网站]</code></pre><h3 id="页面静态资源"><a href="#页面静态资源" class="headerlink" title="页面静态资源"></a>页面静态资源</h3><p>普通页面（包括首页）请求的静态资源，需要在web_accessible_resources中注册一次才可以正常使用，不设置加载不到<br>可以设置通配符，如img文件夹下的文件：”img/*”</p><pre><code>&quot;web_accessible_resources&quot;: [    &quot;icon.png&quot;]</code></pre><p>PS: 自己测试在首页中即使没有添加到web_accessible_resources的图片也加载到了…</p><h3 id="覆盖特定页面"><a href="#覆盖特定页面" class="headerlink" title="覆盖特定页面"></a>覆盖特定页面</h3><p>可覆盖的页面有</p><ul><li>新建空白页 newtab  </li><li>历史记录页面 history  </li><li>书签页 bookmarks</li></ul><p>需要注意的有</p><ul><li>每个插件只能覆盖一种页面，写一种以上会无法加载报错  </li><li>无痕模式的空白页无法代替，即使插件已经在无痕模式开启</li></ul><pre><code>&quot;chrome_url_overrides&quot;: {    &quot;newtab&quot;: &quot;newtab.html&quot; // 此时覆盖的是空白页}</code></pre><h3 id="插件配置页"><a href="#插件配置页" class="headerlink" title="插件配置页"></a>插件配置页</h3><p>在设置——扩展工具的插件中增加配置页功能</p><p>Chrome40以前的版本写法</p><pre><code>&quot;options_page&quot;: &quot;options.html&quot;,</code></pre><p>Chrome40以后的插件配置页写法</p><pre><code>&quot;options_ui&quot;:    {        &quot;page&quot;: &quot;options.html&quot;    }</code></pre><p>如果2个都写的话，新版浏览器只会识别后边的（都写可以兼容）<br>新版增加了一些配置项</p><blockquote><p>browser_style</p><blockquote><p>Boolean<br>更改配置页面的打开方式，false为弹出新的页面，true为弹框<br>目前只知道这一个…</p></blockquote></blockquote><h3 id="待完善"><a href="#待完善" class="headerlink" title="待完善"></a>待完善</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown基础使用</title>
      <link href="/2019-12-05-4.html"/>
      <url>/2019-12-05-4.html</url>
      
        <content type="html"><![CDATA[<div id="title"></div><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><blockquote><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6></blockquote><h4 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h4><pre><code>###...######</code></pre><p>一级到六级标题</p><pre><code>一级标题=======二级标题------</code></pre><p>一级标题和二级标题</p><blockquote><p>一级标题默认带下边带线<br>=和-数量没有限制，只要大于一个就行  </p></blockquote><pre><code># 一级标题 ### 二级标题 ##...###### 六级标题 ######</code></pre><p>一到六级标题</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><ul><li>无序列表</li><li>无序列表</li><li>无序列表</li></ul><ol><li>有序</li><li>有序</li><li>有序<h4 id="方法：-1"><a href="#方法：-1" class="headerlink" title="方法："></a>方法：</h4></li></ol><pre><code>* xxx+ xxx- xxx</code></pre><p>无序列表的三种写法</p><pre><code>1. xxx</code></pre><p><em>有序列表的序列顺序以第一行的为基准向下排</em></p><h2 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h2><h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><blockquote><p> 一级引用</p><blockquote><p>二级引用<br> 一级引用</p><blockquote><p>三级引用<br> 一级引用</p></blockquote></blockquote></blockquote><h4 id="方法：-2"><a href="#方法：-2" class="headerlink" title="方法："></a>方法：</h4><pre><code>&gt;  一级引用&gt;  &gt; 二级引用&gt;  一级引用&gt;  &gt;  &gt; 三级引用&gt;  一级引用</code></pre><p><em>一共有七级引用</em></p><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><h4 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h4><hr><h4 id="方法：-3"><a href="#方法：-3" class="headerlink" title="方法："></a>方法：</h4><pre><code>**** * * ---</code></pre><blockquote><p>大于三个就可以<br>可以有空格<br>必须独占一行</p></blockquote><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h4 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h4><p><a href="http://www.baidu.com" target="_blank" rel="noopener">链接文字</a></p><h4 id="方法：-4"><a href="#方法：-4" class="headerlink" title="方法："></a>方法：</h4><pre><code>[链接文字](http://www.baidu.com)            // 行内式链接</code></pre><pre><code>[链接文字]: http://www.baidu.comxxxxx[链接文字]xxxxx                        // 参数式链接</code></pre><h2 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h2><h4 id="示例：-5"><a href="#示例：-5" class="headerlink" title="示例："></a>示例：</h4><p><a name="view" id="view" href="#title">跳转</a></p><h4 id="方法：-5"><a href="#方法：-5" class="headerlink" title="方法："></a>方法：</h4><pre><code>[跳转](#xxx)// 在需要跳转到的位置&lt;span id=&quot;xxx&quot;&gt;&lt;/span&gt;</code></pre><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><h4 id="示例：-6"><a href="#示例：-6" class="headerlink" title="示例："></a>示例：</h4><p><img src="/blog-img/4-1.jpg" alt="名字"></p><h4 id="方法：-6"><a href="#方法：-6" class="headerlink" title="方法："></a>方法：</h4><pre><code>![名字](http://picture.ik123.com/uploads/allimg/191111/12-191111133323.jpg)            // 行内式图片[名字]: http://picture.ik123.com/uploads/allimg/191111/12-191111133323.jpgxxxxx![名字]xxxxx                        // 参数式图片</code></pre><h2 id="代码框"><a href="#代码框" class="headerlink" title="代码框"></a>代码框</h2><h4 id="示例：-7"><a href="#示例：-7" class="headerlink" title="示例："></a>示例：</h4><p><code>&lt;div&gt;&lt;/div&gt;</code>                        单行代码框</p><pre><code>&lt;div&gt;&lt;/div&gt; 多行代码框</code></pre><h4 id="方法：-7"><a href="#方法：-7" class="headerlink" title="方法："></a>方法：</h4><pre><code>`&lt;div&gt;&lt;/div&gt;`                        // 单行代码框` ` `&lt;div&gt;&lt;/div&gt;                         // 多行代码框` ` `                               // &quot;`&quot;中间没有空格</code></pre><p>表格</p><h4 id="示例：-8"><a href="#示例：-8" class="headerlink" title="示例："></a>示例：</h4><table><thead><tr><th>name</th><th>age</th><th>phone</th></tr></thead><tbody><tr><td>aaa</td><td>18</td><td>110</td></tr><tr><td>bbb</td><td>28</td><td>119</td></tr></tbody></table><h4 id="方法：-8"><a href="#方法：-8" class="headerlink" title="方法："></a>方法：</h4><pre><code>| name | age | phone|| ---- | --- | ---- ||  aaa  |  18  |  110  ||  bbb  |  28  |  119  |            // ---输入一个就可以生效         </code></pre><blockquote><p>:—<br>:—:<br>—:<br>表格中 三种对齐方式</p></blockquote><h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><p>\后边加符号                        转义（和js类似）</p><h2 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h2><h4 id="示例：-9"><a href="#示例：-9" class="headerlink" title="示例："></a>示例：</h4><p><em>倾斜</em><br><strong>加粗</strong><br><del>删除</del>  </p><h4 id="方法：-9"><a href="#方法：-9" class="headerlink" title="方法："></a>方法：</h4><pre><code>*倾斜*                                // 字体倾斜_倾斜_                                // 字体倾斜**加粗**                            // 字体加粗__加粗__                            // 字体加粗~~删除~~                            // 删除线</code></pre><h2 id="Hexo中Markdown问题"><a href="#Hexo中Markdown问题" class="headerlink" title="Hexo中Markdown问题"></a>Hexo中Markdown问题</h2><p>如果在Markdown文件中出现两个连续的<code>}</code>并且不在```的代码块中，会导致Hexo编译错误</p>]]></content>
      
      
      
        <tags>
            
            <tag> MarkDown </tag>
            
            <tag> 文档整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>canvas制作简单表格</title>
      <link href="/2019-12-02-3.html"/>
      <url>/2019-12-02-3.html</url>
      
        <content type="html"><![CDATA[<h2 id="初识canvas，绘制简单表格"><a href="#初识canvas，绘制简单表格" class="headerlink" title="初识canvas，绘制简单表格"></a>初识canvas，绘制简单表格</h2><h4 id="目的，制作一个可以点击的表格"><a href="#目的，制作一个可以点击的表格" class="headerlink" title="目的，制作一个可以点击的表格"></a>目的，制作一个可以点击的表格</h4><blockquote><p>想法： 以每一个小盒子按一定大小排列组成表格，格子的线段采用从顶到底、从左到右的方式绘制整个表格的格子，点击事件以点击时的offsetXY在json中找到对应的值显示（暂时不知道这样写正不正确）</p></blockquote><h5 id="json数据"><a href="#json数据" class="headerlink" title="json数据"></a>json数据</h5><pre><code class="javascript">var data = [    {        name: &quot;改动&quot;,        number1: 53,        number2: 35,        number3: 753,        number4: 35,        number5: 3138    }, {        name: &quot;好地方&quot;,        number1: 4,        number2: 35,        number3: 35,        number4: 38,        number5: 3540    }, {        name: &quot;和人&quot;,        number1: 10,        number2: 8,        number3: 52,        number4: 35,        number5: 7    }, {        name: &quot;加热&quot;,        number1: 435832,        number2: 400,        number3: 53,        number4: 853,        number5: 73    }, {        name: &quot;嗯哼&quot;,        number1: 0,        number2: 450,        number3: 38,        number4: 0,        number5: 7    }, {        name: &quot;好的&quot;,        number1: 77,        number2: 330,        number3: 754,        number4: 354,        number5: 3    }, {        name: &quot;京东方&quot;,        number1: 7500,        number2: 32,        number3: 4,        number4: 3,        number5: 5    }, {        name: &quot;的&quot;,        number1: 5,        number2: 371,        number3: 3,        number4: 2,        number5: 321    }, {        name: &quot;黄日华&quot;,        number1: 43,        number2: 58,        number3: 5,        number4: 463,        number5: 345    }, {        name: &quot;紧随的&quot;,        number1: 664,        number2: 340,        number3: 754,        number4: 3,        number5: 64464    }, {        name: &quot;圣诞节&quot;,        number1: 64,        number2: 23,        number3: 436,        number4: 74,        number5: 345    }, {        name: &quot;倒计时&quot;,        number1: 46400,        number2: 0,        number3: 0,        number4: 0,        number5: 0    }, {        name: &quot;大家都是&quot;,        number1: 34,        number2: 16,        number3: 64,        number4: 743,        number5: 345    }, {        name: &quot;的说法&quot;,        number1: 0,        number2: 24088,        number3: 0,        number4: 0,        number5: 0    }, {        name: &quot; 回复的&quot;,        number1: 35,        number2: 835,        number3: 3465,        number4: 734,        number5: 64    }, {        name: &quot;税点好&quot;,        number1: 734,        number2: 437,        number3: 75,        number4: 745,        number5: 75    }, {        name: &quot;的话&quot;,        number1: 86,        number2: 457,        number3: 845,        number4: 54,        number5: 19328    }, {        name: &quot;额非&quot;,        number1: 123,        number2: 30,        number3: 1200,        number4: 50,        number5: 6    }, {        name: &quot;二就&quot;,        number1: 23,        number2: 9700,        number3: 5,        number4: 6,        number5: 3    }, {        name: &quot;at他&quot;,        number1: 750,        number2: 235,        number3: 6,        number4: 3,        number5: 5    }, {        name: &quot;而言&quot;,        number1: 37,        number2: 53,        number3: 754,        number4: 35,        number5: 7    }];var dataHeader = [&#39;姓名&#39;, &#39;数字1&#39;, &#39;数字2&#39;, &#39;数字3&#39;, &#39;数字4&#39;, &#39;数字5&#39;];</code></pre><h5 id="html"><a href="#html" class="headerlink" title="html"></a>html</h5><pre><code class="html">&lt;div id=&quot;container&quot; style=&quot;position: relative;&quot;&gt;    &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt;    &lt;div id=&quot;div&quot; style=&quot;position: absolute; top: 10px;&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><h5 id="script"><a href="#script" class="headerlink" title="script"></a>script</h5><pre><code class="javascript">var div = document.querySelector(&#39;#div&#39;);var canvas = document.getElementById(&quot;canvas&quot;);var context = canvas.getContext(&quot;2d&quot;);var boxW = 100, boxH = 50;canvas.width = 600;canvas.height = (data.length + 1) * 50;canvas.style.border = &#39;1px solid #222&#39;;setCanvas()function setCanvas() {    // 设置文字格式    context.textAlign = &#39;center&#39;;    context.textBaseline = &#39;middle&#39;;    // 画出头部信息    context.font = &quot;16px Arial&quot;;    dataHeader.forEach((item, i) =&gt; {        context.strokeStyle = &#39;#ffff00&#39;;        context.fillText(item, boxW * i + boxW / 2, boxH / 2);    })    // 画出tbody信息    context.font = &quot;14px Arial&quot;;    data.forEach((item, index) =&gt; {        Object.keys(item).forEach((d, i) =&gt; {            context.strokeStyle = &#39;#ff0000&#39;;            context.fillText(item[d], boxW * i + boxW / 2, boxH * index + boxH + boxH / 2);            context.strokeStyle = &quot;#222&quot;;            // 画出竖边框            context.moveTo(i * boxW, 0);            context.lineTo(i * boxW, boxH * (data.length + 1));            context.stroke();        })        // 画出最后一个竖边框 -&gt;最右侧的        context.moveTo(Object.keys(item).length * boxW, 0);        context.lineTo(Object.keys(item).length * boxW, boxH * (data.length + 1));        context.stroke();    })    // 画出横边框    for (let i = 0; i &lt; data.length + 2; i++) {        context.moveTo(0, i * boxH);        context.lineTo(canvas.width, i * boxH);        context.stroke();    }}var lastX,lastY; // 还原方式重绘存储上次点击事件信息// 绑定点击事件canvas.addEventListener(&#39;click&#39;, function (evt) {    let x = Math.floor(evt.offsetX / boxW); // 获取点击的位置，转换成按钮的 X索引    let y = Math.floor(evt.offsetY / boxH); // 获取点击的位置，转换成按钮的 Y索引    /**    * // 全部重绘逻辑    * // context.clearRect(0, 0, 999, 999); // 清楚canvas，重绘    * // setCanvas(); // 重绘    * // 全部重绘逻辑结束    */    // 还原的方式重绘逻辑 减少内存消耗    // （每次只删除添加的边框，并不删除重绘整个canvas）    if (lastX &gt;= 0 &amp;&amp; lastY &gt;= 0) {        let newX = boxW * lastX;        let newY = boxH * lastY;        context.clearRect(newX + 1, newY + 1, 1, boxH - 2);        context.clearRect(newX + 1, newY + 1, boxW - 2, 1);        context.clearRect(newX + boxW - 2, newY + 1, 1, boxH - 2);        context.clearRect(newX + 1, newY + boxH - 2, boxW - 2, 1);    }    lastX = x;    lastY = y;    // 重绘逻辑结束    context.strokeRect(boxW * x + 1, boxH * y + 1, boxW - 2, boxH - 2) // 绘制点击的边框    data.forEach((item, index) =&gt; { // 循环获取data对象中点击的数据        if (index === y - 1) {            item &amp;&amp; Object.keys(item).forEach((itemData, i) =&gt; {                if (i === x) {                    div.style.left = boxW * dataHeader.length + 20 + &#39;px&#39;;                    div.innerHTML = item[itemData];                }            })        }    })})</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> canvas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue中axios和接口封装</title>
      <link href="/2019-07-24-1.html"/>
      <url>/2019-07-24-1.html</url>
      
        <content type="html"><![CDATA[<h2 id="vue中axios和接口封装"><a href="#vue中axios和接口封装" class="headerlink" title="vue中axios和接口封装"></a>vue中axios和接口封装</h2><pre><code class="javascript">var get = function(modules, _axios) { // 创建axios请求，等待执行    Object.keys(modules).forEach(module =&gt; {        let data = {...modules[module] }        modules[module] = function(payload) {            return _axios({                method: data.method,                url: data.url,                ...payload            })        }    })}function _axios(create, request, response) { // 为axios添加create和拦截    console.log(arguments)    var API = axios.create({        ...create    })    API.interceptors.request.use(request.resolve ? request.resolve : config =&gt; config, request.reject ? request.reject : err =&gt; console.log(err))    API.interceptors.response.use(response.resolve ? response.resolve : response =&gt; response, response.reject ? response.reject : err =&gt; console.log(err))    return API}function getAPI(data) { // 主要函数    var _axios = _axios(data.create ? data.create : {}, data.request ? data.request : {}, data.response ? data.response : {}) // 将传入的create和拦截器放入    var modules = data.modules // 是否模块化分割    if (data.module) { // 模块化分割        Object.keys(modules).forEach(val =&gt; {            let module = modules[val]            get(module, _axios)        })    } else { // 非模块化分割        let module = modules        get(module, _axios)    }    return { modules, _axios }}export default getAPI</code></pre><p>在调用时</p><pre><code class="javascript">import Vue from &quot;vue&quot;;import getAPI from &#39;./index&#39;var apiMod = {    request: { // 请求时拦截        resolve: config =&gt; {            console.log(config)            let token = window.sessionStorage.token            if (token) {                config.headers.authorization = token            }            if (config.url.indexOf(&#39;htm&#39;) &gt; -1 || config.url.indexOf(&#39;userbehavior/export&#39;) &gt; -1 || config.url.indexOf(&#39;order/export&#39;) &gt; -1 || config.url.indexOf(&#39;program/exportProgram&#39;) &gt; -1 || config.url.indexOf(&#39;program/exportCategory&#39;) &gt; -1 || config.url.indexOf(&#39;program/exportTuijian&#39;) &gt; -1) {                config.responseType = &#39;blob&#39;            }            return config        },        reject: err =&gt; {            console.log(err)        }    },    response: { // 响应时拦截        resolve: response =&gt; {            console.log(response)            if (response.headers.authorization) {                window.sessionStorage.token = response.headers.authorization            }            if (response.config.url.indexOf(&#39;htm&#39;) &gt; -1 || response.config.url.indexOf(&#39;userbehavior/export&#39;) &gt; -1 || response.config.url.indexOf(&#39;order/export&#39;) &gt; -1 || response.config.url.indexOf(&#39;program/exportProgram&#39;) &gt; -1 || response.config.url.indexOf(&#39;program/exportCategory&#39;) &gt; -1 || response.config.url.indexOf(&#39;program/exportTuijian&#39;) &gt; -1) {                return response.data            }            if (response.status === 200) {                return response            } else if (response.status &gt; 200 &amp;&amp; response.status &lt; 300) {                return new Promise.reject(err =&gt; {                    console.error(&#39;200错误&#39;, response.status, err)                })            } else if (response.status &gt; 500) {                return new Promise.reject(err =&gt; {                    console.error(&#39;服务器错误&#39;, response.status, err)                })            } else {                return new Promise.reject(err =&gt; {                    console.error(&#39;错误&#39;, response.status, err)                })            }        },        reject: err =&gt; {            console.log(err)        }    },    create: {        baseURL: process.env.VUE_APP_API_URL,        timeout: 10000,    },    module: false, // 不进行模块化    modules: {        login: {            method: &#39;POST&#39;,            url: &#39;/login&#39;,            name: &#39;登录&#39;        },        selectGrailGeneralStatis: {            method: &#39;GET&#39;,            url: &#39;/grail/selectGrailGeneralStatis&#39;,            name: &#39;大盘数据基本信息统计&#39;        },        selectGrailProgramStatis: {            method: &#39;POST&#39;,            url: &#39;/grail/selectGrailProgramStatis&#39;,            name: &#39;大盘数据节目统计&#39;        },        selectGrailCategoryStatis: {            method: &#39;POST&#39;,            url: &#39;/grail/selectGrailCategoryStatis&#39;,            name: &#39;大盘数据栏目统计&#39;        },        exportGrailExcel: {            method: &#39;POST&#39;,            url: &#39;/grail/a.htm&#39;,            name: &#39;导出大盘数据excel&#39;        },    }}let axios = getAPI(apiMod)console.log(axios)Vue.prototype.API = axios.modules</code></pre><p><em>实际使用需做相应调整，仅用于记录一种axios请求封装管理的方法</em></p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原生js复制到剪切板</title>
      <link href="/2019-05-30-2.html"/>
      <url>/2019-05-30-2.html</url>
      
        <content type="html"><![CDATA[<h2 id="原生JS制作复制按钮"><a href="#原生JS制作复制按钮" class="headerlink" title="原生JS制作复制按钮"></a>原生JS制作复制按钮</h2><p>思路是用js来模拟用户操作，首先选中想要复制的内容，进行然后复制操作</p><pre><code>document.querySelector(&#39;button&#39;).onclick = function () {    // 创建一个textarea用来存储要复制的信息    var copyContent = document.createElement(&#39;textarea&#39;);    // 放入要复制的信息    copyContent.innerHTML = `dla1111111111111s`    // 插入节点    document.body.appendChild(copyContent);    // js控制选中textarea中的内容    copyContent.select();    // 执行复制命令***    document.execCommand(&#39;Copy&#39;)    // 删除节点    document.body.removeChild(copyContent)}</code></pre><p><em>兼容ie10+</em></p><p>或者使用插件<a href="https://clipboardjs.com/" target="_blank" rel="noopener">Clipboard.js</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
